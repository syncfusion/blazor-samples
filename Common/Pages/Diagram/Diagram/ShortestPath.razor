@page "/diagram/shortest-path"

@using Syncfusion.Blazor.Diagram
@using Syncfusion.Blazor.Buttons
@*Hidden:Lines*@
@inherits SampleBaseComponent
@implements IDisposable
@inject NavigationManager NavigationManager
@inject IJSRuntime JSRuntime

<SampleDescription>
    <p>
        This sample demonstrates an interactive shortest path algorithm visualization using the Syncfusion<sup>®</sup> Blazor Diagram component, featuring a dynamic graph where users select source and destination nodes to view animated optimal paths.
    </p>
</SampleDescription>
<ActionDescription>
    <p>
        Users can interactively find the shortest path by selecting a <b>"source"</b> node and hovering over a <b>"destination"</b>. The optimal path is dynamically highlighted using animated, dashed connectors and numerical labels. Tooltip instantly display the path sequence or show a <b>"No path found"</b> warning. A toggle allows seamless switching between directed and undirected graph modes.
    </p>
</ActionDescription>

<style>
    .sb-mobile-diagram {
        height: 100%;
    }

    @@media (max-width: 550px) {

        .sb-mobile-diagram {
            width: 100%;
            height: 100%;
            float: left;
            left: 0px;
            border: 1px solid #D7D7D7;
        }
    }
</style>
@*End:Hidden*@

<div style="display: flex; justify-content: center; margin: 20px; align-items: center;">
    <SfSwitch @bind-Checked="IsDirectedGraph" ValueChange="OnGraphTypeChanged" TChecked="bool" aria-label="Toggle directed graph">
    </SfSwitch>
    <label style="margin-left: 15px; font-size: 18px; font-weight: 500;">Directed Graph</label>
</div>
<div id="diagram-space" class="sb-mobile-diagram">
    <SfDiagramComponent Height="700px" @ref="@Diagram" @bind-Nodes="@Nodes" @bind-Connectors="@Connectors" InteractionController="@Tools" Constraints="@Constraints"
                        MouseEnter="OnMouseEnter" MouseLeave="OnMouseLeave" Created="@CreatedEvent" Click="@OnNodeClicked">
        <SnapSettings Constraints=SnapConstraints.None>
        </SnapSettings>
    </SfDiagramComponent>
</div>

@code
{
    // === Constants for colors and styles ===
    public const string NodeHighlightFill = "#6495ED";
    public const string NodeHighlightStroke = "#4472C4";
    public const string NodeDefaultFill = "white";
    public const string NodeDefaultStroke = "#333333";
    public const string NodeErrorFill = "#FF6565";
    public const string NodeErrorStroke = "#EE3636";
    public const string ConnectorHighlightStroke = "#4472C4";
    public const string ConnectorDefaultStroke = "#333333";

    public SfDiagramComponent? Diagram { get; set; }
    // Defines diagram's node and connector collections
    public DiagramObjectCollection<Node>? Nodes { get; set; }
    public DiagramObjectCollection<Connector>? Connectors { get; set; }
    public DiagramInteractions Tools { get; set; } = DiagramInteractions.ZoomPan | DiagramInteractions.SingleSelect;
    public DiagramConstraints Constraints { get; set; } = DiagramConstraints.Default & ~DiagramConstraints.UndoRedo;

    // Change graph to store only neighbors without weights
    public Dictionary<string, List<string>> Graph { get; set; } = new Dictionary<string, List<string>>();

    public string AnnotationContent { get; set; } = "";
    public string SelectedNode { get; set; } = "A";
    public Node? PreviousNode { get; set; }
    public List<string> CurrentPath { get; set; } = new List<string>();
    public List<Node> HighlightedNodes { get; set; } = new List<Node>();
    public List<Connector> HighlightedConnectors { get; set; } = new List<Connector>();
    public bool IsDirectedGraph { get; set; } = true;

    public void CreatedEvent()
    {
        FitOptions options = new FitOptions() { Mode = FitMode.Both, Region = DiagramRegion.PageSettings };
        Diagram!.FitToPage(options);
    }

    public async Task UpdateDecorator(Connector connector, bool isDirectedGraph)
    {
        Diagram!.BeginUpdate();
        try
        {
            connector.TargetDecorator!.Shape = isDirectedGraph ? DecoratorShape.Arrow : DecoratorShape.None;
        }
        finally
        {
            await Diagram.EndUpdateAsync();
        }
    }

    public async Task UpdateStroke(Connector connector, bool isDirectedGraph)
    {
        Diagram!.BeginUpdate();
        try
        {
            if (isDirectedGraph)
            {
                connector.Style!.StrokeWidth = 2;
                connector.Style.StrokeDashArray = "5,5";
                connector.Style.StrokeColor = ConnectorDefaultStroke;
            }
            else
            {
                connector.Style!.StrokeColor = ConnectorDefaultStroke;
                connector.Style.StrokeDashArray = string.Empty;
                connector.Style.StrokeWidth = 2;
            }
        }
        finally
        {
            await Diagram.EndUpdateAsync();
        }
    }

    public async Task OnGraphTypeChanged(ChangeEventArgs<bool> args)
    {
        IsDirectedGraph = args.Checked;
        Diagram!.BeginUpdate();
        try
        {
            foreach (var connectorItem in Connectors!)
            {
                var connector = Diagram.GetObject(connectorItem.ID) as Connector;
                await UpdateDecorator(connector!, IsDirectedGraph);
                await UpdateStroke(connector!, IsDirectedGraph);
                if (!IsDirectedGraph)
                {
                    await FileUtil.RemoveConnectorDash(JSRuntime, connector!.ID!);
                }
            }
        }
        finally
        {
            await Diagram.EndUpdateAsync();
        }
    }
#pragma warning disable CS1998
    protected override async Task OnInitializedAsync()
#pragma warning restore CS1998
    {
        Nodes = new DiagramObjectCollection<Node>();
        Connectors = new DiagramObjectCollection<Connector>();
        CreateNodes();
        CreateConnectors();
        BuildGraph();
    }

    public Node CreateNode(string id, double x, double y)
    {
        return new Node()
        {
            ID = id,
            OffsetX = x,
            OffsetY = y,
            Constraints = (NodeConstraints.Default | NodeConstraints.Tooltip) & ~NodeConstraints.Select,
            Width = 50,
            Height = 50,
            Tooltip = new DiagramTooltip() { OpensOn = "Custom" },
            Shape = new BasicShape() { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Ellipse },
            Style = id == "A" ? new ShapeStyle()
            {
                StrokeColor = NodeHighlightStroke,
                StrokeWidth = 3,
                Fill = NodeHighlightFill
            } : new ShapeStyle() { Fill = NodeDefaultFill },
            Annotations = new DiagramObjectCollection<ShapeAnnotation>()
{
                new ShapeAnnotation()
                {
                    Content = id,
                    Constraints = AnnotationConstraints.ReadOnly,
                    Style = new TextStyle()
                    {
                        Color = "black",
                        FontSize = 16,
                    }
                }
            }
        };
    }

    public void CreateNodes()
    {
        Nodes!.Add(CreateNode("A", 75, 75));
        Nodes.Add(CreateNode("B", 384, 300));
        Nodes.Add(CreateNode("C", 700, 200));
        Nodes.Add(CreateNode("D", 100, 300));
        Nodes.Add(CreateNode("E", 825, 20));
        Nodes.Add(CreateNode("F", 90, 440));
        Nodes.Add(CreateNode("G", 460, 660));
        Nodes.Add(CreateNode("H", 270, 530));
        Nodes.Add(CreateNode("I", 750, 350));
        Nodes.Add(CreateNode("J", 1000, 450));
        Nodes.Add(CreateNode("K", 750, 450));
        Nodes.Add(CreateNode("L", 929, 210));
        Nodes.Add(CreateNode("X", 420, 100));
        Nodes.Add(CreateNode("Y", 850, 620));
    }

    public void CreateConnectors()
    {
        Connectors!.Add(CreateConnector("A", "B"));
        Connectors.Add(CreateConnector("A", "D"));
        Connectors.Add(CreateConnector("A", "X"));
        Connectors.Add(CreateConnector("B", "D"));
        Connectors.Add(CreateConnector("B", "H"));
        Connectors.Add(CreateConnector("B", "X"));
        Connectors.Add(CreateConnector("C", "L"));
        Connectors.Add(CreateConnector("C", "X"));
        Connectors.Add(CreateConnector("D", "F"));
        Connectors.Add(CreateConnector("E", "X"));
        Connectors.Add(CreateConnector("G", "H"));
        Connectors.Add(CreateConnector("G", "Y"));
        Connectors.Add(CreateConnector("H", "F"));
        Connectors.Add(CreateConnector("I", "J"));
        Connectors.Add(CreateConnector("I", "K"));
        Connectors.Add(CreateConnector("I", "L"));
        Connectors.Add(CreateConnector("J", "L"));
        Connectors.Add(CreateConnector("K", "Y"));
        Connectors.Add(CreateConnector("B", "K"));
        Connectors.Add(CreateConnector("B", "C"));
        Connectors.Add(CreateConnector("G", "K"));
        Connectors.Add(CreateConnector("H", "I"));
    }

    public Connector CreateConnector(string sourceId, string targetId)
    {
        return new Connector()
        {
            ID = $"{sourceId}{targetId}",
            SourceID = sourceId,
            TargetID = targetId,
            Type = ConnectorSegmentType.Straight,
            Style = new ShapeStyle()
            {
                StrokeColor = ConnectorDefaultStroke,
                StrokeWidth = 2,
                StrokeDashArray = "5,5"
            },
            Annotations = new DiagramObjectCollection<PathAnnotation>()
{
                new PathAnnotation()
                {
                    Content = "",
                    Style = new TextStyle()
                    {
                        Color = "white",
                        FontSize = 12,
                        Bold = true,
                        Fill = NodeHighlightStroke
                    },
                    Offset = 0.5,
                    Constraints = AnnotationConstraints.ReadOnly,
                    Alignment = AnnotationAlignment.Center,
                    Width = 20,
                    Height = 20
                }
            },
            Constraints = ConnectorConstraints.ReadOnly,
            TargetDecorator = new DecoratorSettings()
            {
                Shape = DecoratorShape.Arrow,
            }
        };
    }

    public void BuildGraph()
    {
        var nodeIds = new[] { "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "X", "Y" };
        foreach (var nodeId in nodeIds)
        {
            Graph[nodeId] = new List<string>();
        }

        var edges = new[]
        {
            new { From = "A", To = "B" },
            new { From = "A", To = "D" },
            new { From = "A", To = "X" },
            new { From = "B", To = "D" },
            new { From = "B", To = "H" },
            new { From = "B", To = "X" },
            new { From = "B", To = "C" },
            new { From = "B", To = "K" },
            new { From = "C", To = "L" },
            new { From = "C", To = "X" },
            new { From = "D", To = "F" },
            new { From = "E", To = "X" },
            new { From = "F", To = "H" },
            new { From = "G", To = "H" },
            new { From = "G", To = "Y" },
            new { From = "G", To = "K" },
            new { From = "H", To = "I" },
            new { From = "I", To = "J" },
            new { From = "I", To = "K" },
            new { From = "I", To = "L" },
            new { From = "J", To = "L" },
            new { From = "K", To = "Y" }
        };

        foreach (var edge in edges)
        {
            Graph[edge.From].Add(edge.To);
            Graph[edge.To].Add(edge.From);
        }
    }


    public async Task OnMouseEnter(DiagramElementMouseEventArgs args)
    {
        if (args.ActualObject is Node hoverNode)
        {
            PreviousNode = hoverNode;
            Diagram!.BeginUpdate();
            try
            {
                if (hoverNode.ID != SelectedNode)
                {
                    await RemoveStepNumbers();
                    await ResetStyles();

                    var (path, distance) = FindShortestPath(SelectedNode, hoverNode.ID!);
                    if (path.Count > 0)
                    {
                        CurrentPath = path;
                        AnnotationContent = string.Join(" → ", path.Select(p => GetNodeLabel(p)));
                        hoverNode.Tooltip!.Content = AnnotationContent;
                        await Diagram.ShowTooltipAsync(hoverNode as IDiagramObject);
                        await HighlightNodes(path);
                        await AddStepNumbersToConnectors(path);
                        await HighlightPath(path);
                    }
                    else
                    {
                        hoverNode.Tooltip!.Content = "No path found";
                        await Diagram.ShowTooltipAsync(hoverNode as IDiagramObject);
                        hoverNode.Style!.Fill = NodeErrorFill;
                        hoverNode.Style.StrokeColor = NodeErrorStroke;
                        if (!HighlightedNodes.Any(n => n.ID == hoverNode.ID))
                        {
                            HighlightedNodes.Add(hoverNode);
                        }
                        Node rootNode = (Diagram.GetObject(SelectedNode) as Node)!;
                        rootNode!.Style!.Fill = NodeErrorFill;
                        rootNode.Style.StrokeColor = NodeErrorStroke;
                    }
                }
            }
            finally
            {
                await Diagram.EndUpdateAsync();
            }
        }
    }

    public async Task RemoveStepNumbers()
    {
        Diagram!.BeginUpdate();
        try
        {
            foreach (var connector in Connectors!)
            {
                if (connector.Annotations!.Count > 0)
                {
                    connector.Annotations[0].Content = "";
                }
            }
        }
        finally
        {
            await Diagram.EndUpdateAsync();
        }
    }

    public async Task OnMouseLeave(DiagramElementMouseEventArgs args)
    {
        Diagram!.BeginUpdate();
        try
        {
            await Diagram.HideTooltipAsync(PreviousNode as IDiagramObject);
            Node? node = Diagram.GetObject(SelectedNode) as Node;
            node!.Style!.StrokeColor = NodeHighlightStroke;
            node.Style.Fill = NodeHighlightFill;
            node.Style.StrokeWidth = 4;
            await ResetStyles();
            await RemoveStepNumbers();
        }
        finally
        {
            await Diagram.EndUpdateAsync();
        }
    }

    public async Task PreviousSelectedNodeUpdated()
    {
        Diagram!.BeginUpdate();
        try
        {
            var previousSelectedNode = Nodes!.FirstOrDefault(n => n.ID == SelectedNode);
            if (previousSelectedNode != null)
            {
                previousSelectedNode.Style!.StrokeColor = NodeDefaultStroke;
                previousSelectedNode.Style.StrokeWidth = 2;
                previousSelectedNode.Style.Fill = NodeDefaultFill;
            }
        }
        finally
        {
            await Diagram.EndUpdateAsync();
        }
    }

    public async Task OnNodeClicked(ClickEventArgs args)
    {
        if (args.Element is Node clickedNode)
        {
            Diagram!.BeginUpdate();
            try
            {
                await PreviousSelectedNodeUpdated();
                await RemoveStepNumbers();
                SelectedNode = clickedNode.ID!;
                clickedNode.Style!.StrokeColor = NodeHighlightStroke;
                clickedNode.Style.StrokeWidth = 3;
                await ResetStyles();
            }
            finally
            {
                await Diagram.EndUpdateAsync();
            }
        }
    }

    public async Task ResetStyles()
    {
        Diagram!.BeginUpdate();
        try
        {
            foreach (var connector in HighlightedConnectors)
            {
                connector.Style!.StrokeColor = ConnectorDefaultStroke;
                connector.Style.StrokeWidth = 2;
                if (IsDirectedGraph)
                {
                    await FileUtil.StopMovingDash(JSRuntime, connector.ID + "_path");
                }
            }
            HighlightedConnectors.Clear();

            foreach (var node in HighlightedNodes)
            {
                if (node.ID != SelectedNode)
                {
                    node.Style!.Fill = NodeDefaultFill;
                    node.Style.StrokeColor = NodeDefaultStroke;
                    node.Style.StrokeWidth = 2;
                }
            }
            HighlightedNodes.Clear();
        }
        finally
        {
            await Diagram.EndUpdateAsync();
        }
    }

    public List<string> GetNeighbors(string nodeId, bool directed)
    {
        if (!directed)
        {
            // For undirected graph, return all connected nodes
            return Graph[nodeId];
        }
        else
        {
            // For directed graph, only return nodes that this node points to
            var neighbors = new List<string>();
            var outgoingConnectors = Connectors!.Where(c => c.SourceID == nodeId);
            foreach (var connector in outgoingConnectors)
            {
                neighbors.Add(connector.TargetID!);
            }
            return neighbors;
        }
    }

    public (List<string> path, int distance) FindShortestPath(string start, string end)
    {
        if (!Graph.ContainsKey(start) || !Graph.ContainsKey(end))
            return (new List<string>(), 0);
        if (start == end)
            return (new List<string> { start }, 0);

        var queue = new Queue<string>();
        var visited = new HashSet<string>();
        var previous = new Dictionary<string, string>();
        var distances = new Dictionary<string, int>();

        queue.Enqueue(start);
        visited.Add(start);
        distances[start] = 0;

        while (queue.Count > 0)
        {
            var current = queue.Dequeue();

            // Get neighbors based on graph type
            var neighbors = GetNeighbors(current, IsDirectedGraph);

            foreach (var neighbor in neighbors)
            {
                if (!visited.Contains(neighbor))
                {
                    visited.Add(neighbor);
                    previous[neighbor] = current;
                    distances[neighbor] = distances[current] + 1;
                    queue.Enqueue(neighbor);
                    if (neighbor == end)
                        break;
                }
            }
            if (visited.Contains(end))
                break;
        }

        var path = new List<string>();
        if (visited.Contains(end))
        {
            var currentNode = end;
            while (currentNode != null)
            {
                path.Insert(0, currentNode);
                previous.TryGetValue(currentNode, out currentNode);
            }
        }

        return (path, path.Count > 0 ? path.Count - 1 : 0);
    }

    public async Task HighlightNodes(List<string> path)
    {
        Diagram!.BeginUpdate();
        try
        {
            for (int i = 0; i < path.Count; i++)
            {
                Node? node = Diagram.GetObject(path[i]) as Node;
                if (node != null)
                {
                    node.Style!.Fill = NodeHighlightFill;
                    node.Style.StrokeColor = NodeHighlightStroke;
                    node.Style.StrokeWidth = 3;
                    HighlightedNodes.Add(node);
                }
            }
        }
        finally
        {
            await Diagram.EndUpdateAsync();
        }
    }

    public Connector FindConnector(string sourceId, string targetId)
    {
        return Connectors!.FirstOrDefault(c =>
            (c.SourceID == sourceId && c.TargetID == targetId) ||
            (!IsDirectedGraph && c.SourceID == targetId && c.TargetID == sourceId))!;
    }

    public async Task HighlightPath(List<string> path)
    {
        Diagram!.BeginUpdate();
        try
        {
            for (int i = 0; i < path.Count - 1; i++)
            {
                var connector = FindConnector(path[i], path[i + 1]);
                if (connector != null)
                {
                    connector.Style!.StrokeColor = ConnectorHighlightStroke;
                    connector.Style.StrokeWidth = 4;
                    HighlightedConnectors.Add(connector);
                    if (IsDirectedGraph)
                    {
                        await FileUtil.StartMovingDash(JSRuntime, connector.ID + "_path");
                    }
                }
            }
        }
        finally
        {
            await Diagram.EndUpdateAsync();
        }
    }

    public async Task AddStepNumbersToConnectors(List<string> path)
    {
        Diagram!.BeginUpdate();
        try
        {
            for (int i = 0; i < path.Count - 1; i++)
            {
                var connector = FindConnector(path[i], path[i + 1]);
                if (connector != null)
                {
                    connector.Annotations![0].Content = (i + 1).ToString();
                }
            }
        }
        finally
        {
            await Diagram.EndUpdateAsync();
        }
    }

    public string GetNodeLabel(string nodeId)
    {
        var node = Nodes!.FirstOrDefault(n => n.ID == nodeId);
        return node?.Annotations![0]?.Content ?? nodeId;
    }

    @*Hidden:Lines*@
    public void Dispose()
    {
        if (HighlightedConnectors != null)
        {
            foreach (var connector in HighlightedConnectors)
            {
                if (IsDirectedGraph)
                {
                    _ = FileUtil.StopMovingDash(JSRuntime, connector.ID + "_path");
                }
            }
        }
        if (Nodes != null)
        {
            Nodes.Clear();
            Nodes = null;
        }
        if (Connectors != null)
        {
            Connectors.Clear();
            Connectors = null;
        }
    }
    @*End:Hidden*@
}
