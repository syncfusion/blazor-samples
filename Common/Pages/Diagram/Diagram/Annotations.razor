@page "/diagram/annotations"

@using Syncfusion.Blazor.Diagram
@using System.Collections.ObjectModel
@using Syncfusion.Blazor.Buttons
@using Syncfusion.Blazor.Inputs
@using Syncfusion.Blazor.DropDowns
@using NodeShape = Syncfusion.Blazor.Diagram.NodeShapes
@using SelectionChangedEventArgs = Syncfusion.Blazor.Diagram.SelectionChangedEventArgs

@*Hidden:Lines*@
@inherits SampleBaseComponent
@implements IDisposable
@*End:Hidden*@

@*Hidden:Lines*@
<SampleDescription>
   <p>This sample illustrates how to add textual descriptions to shapes and customize the position and appearance of the annotation. </p>
</SampleDescription>
<ActionDescription>
    <p>
        This example shows how to add textual descriptions to shapes, how to position them over the shapes, and customize the description's position and appearance. To change the position of the description, select a node and choose the template in the property panel. The <code><a target="_blank" href="https://help.syncfusion.com/cr/blazor/Syncfusion.Blazor.Diagram.Node.html#Syncfusion_Blazor_Diagram_Node_Annotations" aria-label="Annotations">Annotations</a></code> property can be used to add descriptions.
    </p>
    <p>
        The <code><a target="_blank" href="https://help.syncfusion.com/cr/blazor/Syncfusion.Blazor.Diagram.ShapeAnnotation.html#Syncfusion_Blazor_Diagram_ShapeAnnotation_Offset" aria-label="Offset">Offset</a></code>, <code><a target="_blank" href="https://help.syncfusion.com/cr/blazor/Syncfusion.Blazor.Diagram.Annotation.html#Syncfusion_Blazor_Diagram_Annotation_HorizontalAlignment" aria-label="HorizontalAlignment">HorizontalAlignment</a></code>, and <code><a target="_blank" href="https://help.syncfusion.com/cr/blazor/Syncfusion.Blazor.Diagram.Annotation.html#Syncfusion_Blazor_Diagram_Annotation_VerticalAlignment" aria-label="VerticalAlignment">VerticalAlignment</a></code> properties are used to customize the position of the descriptions. The <code><a target="_blank" href="https://help.syncfusion.com/cr/blazor/Syncfusion.Blazor.Diagram.TextStyle.html#Syncfusion_Blazor_Diagram_TextStyle_Bold" aria-label="Bold">Bold</a></code>, <code><a target="_blank" href="https://help.syncfusion.com/cr/blazor/Syncfusion.Blazor.Diagram.TextStyle.html#Syncfusion_Blazor_Diagram_TextStyle_Italic" aria-label="Italic">Italic</a></code>, <code><a target="_blank" href="https://help.syncfusion.com/cr/blazor/Syncfusion.Blazor.Diagram.TextStyle.html#Syncfusion_Blazor_Diagram_TextStyle_FontSize" aria-label="FontSize">FontSize</a></code>, and <code><a target="_blank" href="https://help.syncfusion.com/cr/blazor/Syncfusion.Blazor.Diagram.TextStyle.html#Syncfusion_Blazor_Diagram_TextStyle_FontFamily" aria-label="FontFamily">FontFamily</a></code> properties are used to customize the appearance of the descriptions.
    </p>
</ActionDescription>
@*End:Hidden*@

@*Hidden:Lines*@
<div class="annotaion-sample">
    <div class="col-lg-9 control-section sb-property-border">
        @*End:Hidden*@

        <div id="diagram-space" class="content-wrapper">
            <SfDiagramComponent Height="640px" Constraints="@Constraints" @ref="@DiagramInstance" Created="OnCreated" SelectionChanged="@SelectionChanged" Nodes="@DiagramNodes" Connectors="@DiagramConnectors">
                <SnapSettings Constraints=SnapConstraints.ShowLines>
                </SnapSettings>
            </SfDiagramComponent>
        </div>
        @*Hidden:Lines*@
    </div>
    @*End:Hidden*@
    @*Hidden:Lines*@
    <div class="col-lg-3 property-section">
        <div class="property-panel-header">
            Properties
        </div>
        <fieldset>
            <div class="@AppearanceClass">
                <div class="row property-panel-content" id="appearance">
                    <div class="row row-header" style="padding-top: 10px">
                        Alignment
                    </div>
                    <div class="row">
                        <div class="row" style="padding-top: 8px">
                            <div class="@AlignmentOptions["left"]" id="left" @onclick="@(() => UpdatePosition("left"))" style="background-image: url(@("https://cdn.syncfusion.com/blazor/images/diagram/annotation/top-left.png")); margin-right: 4px;pointer-events:@SelectedNode">
                            </div>
                            <div class="@AlignmentOptions["right"]" id="right" @onclick="@(() => UpdatePosition("right"))" style="background-image: url(@("https://cdn.syncfusion.com/blazor/images/diagram/annotation/top-right.png")); margin: 0px 4px;pointer-events:@SelectedNode">
                            </div>
                            <div class="@AlignmentOptions["bottoml"]" id="bottoml" @onclick="@(() => UpdatePosition("bottoml"))" style="background-image: url(@("https://cdn.syncfusion.com/blazor/images/diagram/annotation/bottom-left.png"));margin-left: 4px;pointer-events:@SelectedNode">
                            </div>
                        </div>
                        <div class="row" style="padding-top: 8px">
                            <div class="@AlignmentOptions["bottomr"]" id="bottomr" @onclick="@(() => UpdatePosition("bottomr"))" style="background-image: url(@("https://cdn.syncfusion.com/blazor/images/diagram/annotation/bottom-right.png")); margin-right: 4px;pointer-events:@SelectedNode">
                            </div>
                            <div class="@AlignmentOptions["center"]" id="center" @onclick="@(() => UpdatePosition("center"))" style="background-image: url(@("https://cdn.syncfusion.com/blazor/images/diagram/annotation/center.png")); margin: 0px 4px;pointer-events:@SelectedNode">
                            </div>
                            <div class="@AlignmentOptions["bottomcenter_top"]" id="bottomcenter_top" @onclick="@(() => UpdatePosition("bottomcenter_top"))" style="background-image: url(@("https://cdn.syncfusion.com/blazor/images/diagram/annotation/bottom-center.png"));margin-left: 4px;pointer-events:@SelectedNode">
                            </div>
                        </div>
                        <div class="row" style="padding-top: 8px">
                            <div class="@AlignmentOptions["sourcetext"]" id="bottomr" @onclick="@(() => UpdatePosition("sourcetext"))" style="background-image: url(@("https://cdn.syncfusion.com/blazor/images/diagram/annotation/sourcetext.png")); margin-right: 4px ;pointer-events:@SelectedConnector">
                            </div>
                            <div class="@AlignmentOptions["targettext"]" id="center" @onclick="@(() => UpdatePosition("targettext"))" style="background-image: url(@("https://cdn.syncfusion.com/blazor/images/diagram/annotation/targettext.png")); margin: 0px 4px;pointer-events:@SelectedConnector">
                            </div>
                            <div class="@AlignmentOptions["abovecenter"]" id="bottomcenter_top" @onclick="@(() => UpdatePosition("abovecenter"))" style="background-image: url(@("https://cdn.syncfusion.com/blazor/images/diagram/annotation/abovecenter.png")); margin-left: 4px;pointer-events:@SelectedConnector">
                            </div>
                        </div>
                        <div class="row" style="padding-top: 8px">
                            <div class="@AlignmentOptions["belowcenter"]" id="bottomr" @onclick="@(() => UpdatePosition("belowcenter"))" style="background-image: url(@("https://cdn.syncfusion.com/blazor/images/diagram/annotation/belowcenter.png")); margin-right: 4px;pointer-events:@SelectedConnector">
                            </div>
                            <div class="@AlignmentOptions["centertext"]" id="center" @onclick="@(() => UpdatePosition("centertext"))" style="background-image: url(@("https://cdn.syncfusion.com/blazor/images/diagram/annotation/centertext.png")); margin: 0px 4px;pointer-events:@SelectedConnector">
                            </div>

                        </div>
                    </div>
                </div>

                <div class="row property-panel-content" style="padding-top: 10px">
                    <div class="row row-header" style="padding-top: 10px">
                        Appearance
                    </div>
                    <div class="row" style="padding-top: 8px">
                        <div class="buttonstyle">
                            <SfButton  @bind-Disabled="IsBoldDisabled" ID="bold" OnClick="ApplyFontBold" CssClass="boldwidth button" iconCss="e-btn-icon e-bold e-icons"></SfButton>
                        </div>
                        <div class="buttonstyle ">
                            <SfButton  ID="italic" @bind-Disabled="IsItalic" OnClick="ApplyFontItalic" CssClass="boldwidth button" iconCss="e-btn-icon e-italic e-icons"></SfButton>
                        </div>
                        <div class="buttonstyle">
                            <SfButton ID="underline" @bind-Disabled="IsUnderline" OnClick="ApplyFontUnderline" CssClass="boldwidth button" iconCss="e-btn-icon e-underline e-icons"></SfButton>
                        </div>
                    </div>
                    <div class="row" style="padding-top: 8px">
                        <div class="texstyle">
                            Font Size
                        </div>
                        <div class="col-xs-6">
                            <SfNumericTextBox ID="fontSize" TValue="int" @bind-Value="@FontSizeValue" Min="10" Max="50" @bind-Enabled="IsFontEnabled" Format="##.##" Step="1" Width="130px" CssClass="textboxstyle">
                                <NumericTextBoxEvents TValue="int" ValueChange="@ChangeFontSize"></NumericTextBoxEvents>
                            </SfNumericTextBox>
                        </div>
                    </div>
                    <div class="row" style="padding-top: 8px">
                        <div class="texstyle">
                            Font Style
                        </div>
                        <div class="col-xs-6">
                            <SfDropDownList TValue="@string" Width="130px" TItem="@FontFamily" @bind-Value="@FontStyle" ID="fontFamily" @bind-Enabled="@IsFontFamilyEnabled" PopupHeight="120" Placeholder="Select a font type" CssClass="textboxstyle" PopupWidth="150" DataSource="@FontFamilyLists">
                                <DropDownListEvents TItem="FontFamily" TValue="string" ValueChange="ChangeFontFamily"></DropDownListEvents>
                                <DropDownListFieldSettings Text="Name" Value="Name"></DropDownListFieldSettings>
                            </SfDropDownList>
                        </div>
                    </div>
                    <div class="row" style="padding-top: 8px">
                        <div class="texstyle">
                            Text Wrapping
                        </div>
                        <div class="col-xs-6">
                            <SfDropDownList TValue="@string" Width="130px" TItem="@TextWrapping" @bind-Value="@TextWrappingOption" @bind-Enabled="IsTextWrappingEnabled" ID="TextWrapping" Placeholder="NoWrap" CssClass="textboxstyle" PopupWidth="150" DataSource="@TextWrappingList">
                                <DropDownListEvents TItem="TextWrapping" TValue="string" ValueChange="ChangeTextWrapping"></DropDownListEvents>
                                <DropDownListFieldSettings Text="Name" Value="Name"></DropDownListFieldSettings>
                            </SfDropDownList>
                        </div>
                    </div>
                    <div class="row" style="padding-top: 8px">
                        <div class="texstyle">
                            Text Overflow
                        </div>
                        <div class="col-xs-6">
                            <SfDropDownList TValue="@string" Width="130px" TItem="@TextOverFlow" @bind-Value="@TextOverflowOption" ID="TextOverFlow" @bind-Enabled="IsTextOverflowEnabled" Placeholder="Wrap" CssClass="textboxstyle" PopupWidth="150" DataSource="@TextOverFlowList">
                                <DropDownListEvents TItem="TextOverFlow" TValue="string" ValueChange="ChangeTextOverflow"></DropDownListEvents>
                                <DropDownListFieldSettings Text="Name" Value="Name"></DropDownListFieldSettings>
                            </SfDropDownList>
                        </div>
                    </div>
                    <div class="row" style="padding-top: 8px">
                        <div class="texstyle">
                            Font Color
                        </div>
                        <div class="col-xs-6">
                            <SfColorPicker @bind-Disabled="IsColorPickerEnabled" ValueChange="OnFillColorChange" @bind-Value="@FillColor"></SfColorPicker>
                        </div>
                    </div>
                </div>
            </div>
        </fieldset>
    </div>
</div>
@*End:Hidden*@
@code
{
    @*Hidden:Lines*@ 
private bool IsBoldDisabled { get; set; } = false;
public string SelectedNode { get; set; } = "";
public string SelectedConnector { get; set; } = "none";
public bool IsItalic { get; set; } = false;
public bool IsUnderline { get; set; } = false;
public bool IsFontFamilyEnabled { get; set; } = true;
public bool IsTextWrappingEnabled { get; set; } = true;
public bool IsTextOverflowEnabled { get; set; } = true;
public bool IsFontEnabled { get; set; } = true;
public bool IsColorPickerEnabled { get; set; } = false;
public string SelectedPanel { get; set; } = "center";
private bool IsPanelUpdateOnly { get; set; } = false;
public string AppearanceClass { get; set; } = "e-remove-selection";
private const string SelectedItemClass = "image-pattern-style e-selected-style";
public int FontSizeValue { get; set; } = 12;
public string FillColor { get; set; } = "#000";
public string TextWrappingOption { get; set; } = "NoWrap";
public string FontStyle { get; set; } = "Arial";
public string TextOverflowOption { get; set; } = "Wrap";
private const string UnselectedItemClass = "image-pattern-style";

public string StyleValue { get; set; } = "background-color:#008000";

// Define bold, italic, underline button
public SfButton? BoldButton { get; set; }
public SfButton? ItalicButton { get; set; }
public SfButton? UnderlineButton { get; set; }
public SfNumericTextBox<int>? FontSizeBox { get; set; }

    //Define selected item/unselected item AlignmentOptions
    Dictionary<string, string> AlignmentOptions = new Dictionary<string, string>() { { "left", UnselectedItemClass }, { "centertext", UnselectedItemClass }, { "belowcenter", UnselectedItemClass }, { "abovecenter", UnselectedItemClass }, { "targettext", UnselectedItemClass }, { "sourcetext", UnselectedItemClass }, { "right", UnselectedItemClass }, { "center", UnselectedItemClass }, { "bottomr", UnselectedItemClass }, { "bottoml", UnselectedItemClass }, { "bottomcenter_top", UnselectedItemClass } };

    @*End:Hidden*@

    //Define sfdiagramComponent
    SfDiagramComponent? DiagramInstance { get; set; }

    public DiagramConstraints Constraints { get; set; }

    //Defines diagrams's nodes collection
    public DiagramObjectCollection<Node>? DiagramNodes = new DiagramObjectCollection<Node>();

    //Defines diagrams's connectors collection
    public DiagramObjectCollection<Connector>? DiagramConnectors = new DiagramObjectCollection<Connector>();

    private void OnCreated()
    {
        DiagramInstance?.Select(new ObservableCollection<IDiagramObject>() { DiagramInstance.Nodes![2] });
        FitOptions options = new FitOptions() { Mode = FitMode.Both, Region = DiagramRegion.Content };
        DiagramInstance?.FitToPage(options);
    }

    protected override void OnInitialized()
    {

        Constraints = DiagramConstraints.Default;

        Node newProject = CreateNode(130, 40, 430, 80, NodeFlowShapes.Terminator, "New project", "newProject");
        Node design = CreateNode(170, 40, 430, 160, NodeFlowShapes.Process, "Project planning and designing", "design");
        Node coding = CreateNode(130, 40, 430, 250, NodeFlowShapes.Process, "Development", "coding");
        Node testing = CreateNode(130, 40, 430, 360, NodeFlowShapes.Process, "Testing", "testing");
        Node errors = CreateNode(200, 50, 430, 470, NodeFlowShapes.Decision, "Is errors?", "errors");
        Node completed = CreateNode(130, 40, 430, 570, NodeFlowShapes.Terminator, "Project completed", "completed");

        CreateNodePort(design, "designPort", 0, 0.5);
        CreateNodePort(coding, "codingPort", 1, 0.5);
        CreateNodePort(errors, "errorsPort2", 1, 0.5);
        CreateNodePort(errors, "errorsPort1", 0, 0.5);
        OrthogonalSegment designOrthogonalSegment = new OrthogonalSegment()
        {
            Type = ConnectorSegmentType.Orthogonal,
            Direction = Direction.Left,
            Length = 120,
        };
        OrthogonalSegment codingOrthogonalSegment = new OrthogonalSegment
        {
            Type = ConnectorSegmentType.Orthogonal,
            Length = 100,
            Direction = Direction.Right,
        };
        DiagramObjectCollection<ConnectorSegment> designSegment = new DiagramObjectCollection<ConnectorSegment>() { designOrthogonalSegment };

        DiagramObjectCollection<ConnectorSegment> codingSegment = new DiagramObjectCollection<ConnectorSegment>() { codingOrthogonalSegment };

        CreateConnector("newProject", "design", "", null, null, null);
        CreateConnector("design", "coding", "", null, null, null);
        CreateConnector("coding", "testing", "Coding completed", null, null, null);
        CreateConnector("testing", "errors", "Testing completed", null, null, null);
        CreateConnector("errors", "completed", "No errors", null, null, null);
        CreateConnector("errors", "coding", "Production issues", "errorsPort2", "codingPort", codingSegment);
        CreateConnector("errors", "design", "Design errors", "errorsPort1", "designPort", designSegment);
    }

    //Create nodes
    private Node CreateNode(double unitWidth, double unitHeight, double offsetx, double offsety, NodeFlowShapes shape, string text, string id)
    {
        TextStyle textStyle = new TextStyle() { FontSize = 13, TextWrapping = TextWrap.WrapWithOverflow, Bold = true };
        ShapeAnnotation shapeAnnotation = new ShapeAnnotation() { Content = text, Style = textStyle };
        Node node = new Node()
        {
            Width = unitWidth,
            Height = unitHeight,
            OffsetX = offsetx,
            OffsetY = offsety,
            ID = id,
            Style = new ShapeStyle() { Fill = "#98FB98", StrokeColor = "#008000" },
            Shape = new FlowShape() { Shape = shape, Type = NodeShape.Flow },
            Annotations = new DiagramObjectCollection<ShapeAnnotation>() { shapeAnnotation }
        };
        DiagramNodes!.Add(node);
        return node;
    }

    //Create ports
    private void CreateNodePort(Node node, string id, double nodeoffsetx, double nodeoffsety)
    {
        PointPort nodePort = new PointPort()
        {
            ID = id,
            Offset = new DiagramPoint() { X = nodeoffsetx, Y = nodeoffsety },
        };

        node.Ports?.Add(nodePort);
    }

    //Create connectors
    private void CreateConnector(string sourceNode, string targetNode, string text,
      string? sourcePort, string? targetPort, DiagramObjectCollection<ConnectorSegment>? segment = null)
    {
        TextStyle textStyle = new TextStyle() { FontSize = 13, TextWrapping = TextWrap.WrapWithOverflow, Bold = true };
        PathAnnotation pathAnnotation = new PathAnnotation() { Content = text, Style = textStyle };
        Connector connector = new Connector()
        {
            SourceID = sourceNode,
            TargetID = targetNode,
            SourcePortID = sourcePort,
            TargetPortID = targetPort,
            Style = new ShapeStyle() { Fill = "#008000", StrokeWidth = 1 },
            Annotations = new DiagramObjectCollection<PathAnnotation>() { pathAnnotation },
        };
        if (segment != null)
        {
            connector.Type = ConnectorSegmentType.Orthogonal;
            connector.Segments = segment;
        }
        DiagramConnectors!.Add(connector);
    }

    //Update annotation bold property
    private void ApplyFontBold()
    {
        UpdateAnnotation("bold", true);
    }

    //Update annotation italic property
    private void ApplyFontItalic()
    {
        UpdateAnnotation("italic", true);
    }

    //Update annotation underline property
    private void ApplyFontUnderline()
    {
        UpdateAnnotation("underline", true);
    }

    //Update annotation fontfamily
    private void ChangeFontFamily(ChangeEventArgs<string, FontFamily> args)
    {
        UpdateAnnotation("fontfamily", args.Value!);
    }

    //Update annotation textwrap property
    private void ChangeTextWrapping(ChangeEventArgs<string, TextWrapping> args)
    {
        UpdateAnnotation("textwrapping", args.Value!);
    }

    //Update annotation textoverflow property
    private void ChangeTextOverflow(ChangeEventArgs<string, TextOverFlow> args)
    {
        UpdateAnnotation("textoverflow", args.Value!);
    }
    //Update annotation fontsize value
    private void ChangeFontSize(Syncfusion.Blazor.Inputs.ChangeEventArgs<int> args)
    {
        FontSizeValue = int.Parse(args.Value.ToString());
        UpdateAnnotation("fontsize", FontSizeValue);
    }
    private void SelectionChanged(SelectionChangedEventArgs args)
    {
        if (args.NewValue?.Count > 0)
        {
            if (args.NewValue[0] is Node)
            {
                SelectedNode = "";
                SelectedConnector = "none";
                ShapeAnnotation? shapeAnnotation = (args.NewValue[0] as Node)?.Annotations?[0];
                HorizontalAlignment? horizontalAlignment = shapeAnnotation?.HorizontalAlignment;
                VerticalAlignment? verticalAlignment = shapeAnnotation!.VerticalAlignment;
                if (horizontalAlignment == HorizontalAlignment.Center && verticalAlignment == VerticalAlignment.Center)
                {
                    UpdateSelection("center");
                }
                else if (horizontalAlignment == HorizontalAlignment.Left && verticalAlignment == VerticalAlignment.Top)
                {
                    UpdateSelection("bottomr");
                }
                else if (horizontalAlignment == HorizontalAlignment.Right && verticalAlignment == VerticalAlignment.Top)
                {
                    UpdateSelection("bottoml");
                }
                else if (horizontalAlignment == HorizontalAlignment.Left && verticalAlignment == VerticalAlignment.Bottom)
                {
                    UpdateSelection("right");
                }
                else if (horizontalAlignment == HorizontalAlignment.Right && verticalAlignment == VerticalAlignment.Bottom)
                {
                    UpdateSelection("left");
                }
                else if (horizontalAlignment == HorizontalAlignment.Center && verticalAlignment == VerticalAlignment.Bottom)
                {
                    UpdateSelection("bottomcenter_top");
                }
                if (shapeAnnotation.Style?.Color == "black")
                {
                    shapeAnnotation.Style.Color = "#000";
                }
                FillColor = shapeAnnotation.Style!.Color!;
                TextWrappingOption = shapeAnnotation.Style!.TextWrapping.ToString();
                TextOverflowOption = shapeAnnotation.Style.TextOverflow.ToString();
                FontStyle = shapeAnnotation.Style.FontFamily!;
                FontSizeValue = ((int)shapeAnnotation.Style.FontSize);
            }
            if (args.NewValue[0] is Connector)
            {
                SelectedConnector = "";
                SelectedNode = "none";
                PathAnnotation pathAnnotation = (args.NewValue[0] as Connector)!.Annotations![0];
                if (pathAnnotation.Offset == 0)
                {
                    UpdateSelection("sourcetext");
                }
                else if (pathAnnotation.Offset == 1)
                {
                    UpdateSelection("targettext");
                }
                else if (pathAnnotation.Offset == 0.5 && pathAnnotation.Alignment == AnnotationAlignment.After)
                {
                    UpdateSelection("abovecenter");
                }
                else if (pathAnnotation.Offset == 0.5 && pathAnnotation.Alignment == AnnotationAlignment.Before)
                {
                    UpdateSelection("belowcenter");
                }
                else if (pathAnnotation.Offset == 0.5 && pathAnnotation.Alignment == AnnotationAlignment.Center)
                {
                    UpdateSelection("centertext");
                }
                if (pathAnnotation.Style!.Color == "black")
                {
                    pathAnnotation.Style.Color = "#000";
                }
                FillColor = pathAnnotation.Style.Color!;
                TextWrappingOption = pathAnnotation.Style.TextWrapping.ToString();
                TextOverflowOption = pathAnnotation.Style.TextOverflow.ToString();
                FontStyle = pathAnnotation.Style.FontFamily!;
                FontSizeValue = ((int)pathAnnotation.Style.FontSize);
            }
        }
        if (args.NewValue != null && args.NewValue.Count > 0)
        {
            AlignmentOptions[SelectedPanel] = SelectedItemClass;
            if (args.NewValue[0] is Node)
            {
                SelectedNode = "";
                SelectedConnector = "none";
            }
            else if (args.NewValue[0] is Connector)
            {
                SelectedNode = "none";
                SelectedConnector = "";
            }
        }
        else
        {
            AlignmentOptions = new Dictionary<string, string>() { { "left", UnselectedItemClass }, { "centertext", UnselectedItemClass }, { "belowcenter", UnselectedItemClass }, { "abovecenter", UnselectedItemClass }, { "targettext", UnselectedItemClass }, { "sourcetext", UnselectedItemClass }, { "right", UnselectedItemClass }, { "center", UnselectedItemClass }, { "bottomr", UnselectedItemClass }, { "bottoml", UnselectedItemClass }, { "bottomcenter_top", UnselectedItemClass } };
            SelectedNode = "none";
            SelectedConnector = "none";
        }
        if (DiagramInstance!.SelectionSettings!.Nodes!.Count > 0 || DiagramInstance.SelectionSettings.Connectors!.Count > 0)
        {
            IsBoldDisabled = false;
            IsItalic = false;
            IsUnderline = false;
            IsFontFamilyEnabled = true;
            IsTextOverflowEnabled = true;
            IsTextWrappingEnabled = true;
            IsColorPickerEnabled = false;
            IsFontEnabled = true;
        }
        else
        {
            IsBoldDisabled = true;
            IsItalic = true;
            IsUnderline = true;
            IsFontFamilyEnabled = false;
            IsTextOverflowEnabled = false;
            IsTextWrappingEnabled = false;
            IsColorPickerEnabled = true;
            IsFontEnabled = false;
        }
    }

    //Update fill color for annotations
    public void OnFillColorChange(ColorPickerEventArgs args)
    {
        this.StyleValue  = "background-color:" + args.CurrentValue!.Hex;
        UpdateAnnotation("fontcolor", args.CurrentValue.Hex!);
    }

    //Update annotation
    private void UpdateAnnotation(string name, object value)
    {
        if (DiagramInstance!.SelectionSettings!.Connectors!.Count > 0)
        {
            for (var i = 0; i < DiagramInstance.SelectionSettings.Connectors.Count; i++)
            {
                var connector = DiagramInstance.SelectionSettings.Connectors[i];
                for (var j = 0; j < connector.Annotations!.Count; j++)
                {
                    TextStyle annotationStyle = connector.Annotations[j].Style!;
                    UpdateAnnotationStyle(name, annotationStyle, value);

                }
            }
        }
        if (DiagramInstance.SelectionSettings.Nodes!.Count > 0)
        {
            for (var i = 0; i < DiagramInstance.SelectionSettings.Nodes.Count; i++)
            {
                var node = DiagramInstance.SelectionSettings.Nodes[i];
                for (var j = 0; j < node.Annotations!.Count; j++)
                {
                    TextStyle annotationStyle = node.Annotations[j].Style!;
                    UpdateAnnotationStyle(name, annotationStyle, value);
                }
            }
        }
    }

    //Update annotation style
    private void UpdateAnnotationStyle(string option, TextStyle textStyle, object value)
    {
        switch (option)
        {
            case "fontsize":
                textStyle.FontSize = Double.Parse(value.ToString()!);
                break;
            case "underline":
                textStyle.TextDecoration = textStyle.TextDecoration == TextDecoration.Underline ? TextDecoration.None : TextDecoration.Underline;
                break;
            case "fontfamily":
                textStyle.FontFamily = value.ToString();
                break;
            case "bold":
                if (textStyle.Bold)
                    textStyle.Bold = false;
                else
                    textStyle.Bold = true;
                break;
            case "italic":
                if (textStyle.Italic)
                    textStyle.Italic = false;
                else
                    textStyle.Italic = true;
                break;
            case "fontcolor":
                textStyle.Color = value.ToString();
                break;
            case "textwrapping":
                string textwrap = value.ToString()!;
                if (textwrap == "NoWrap")
                {
                    textStyle.TextWrapping = TextWrap.NoWrap;
                }
                else if (textwrap == "Wrap")
                {
                    textStyle.TextWrapping = TextWrap.Wrap;
                }
                else if (textwrap == "WrapWithOverflow")
                {
                    textStyle.TextWrapping = TextWrap.WrapWithOverflow;
                }
                break;
            case "textoverflow":
                string textOverFlow = value.ToString()!;
                if (textOverFlow == "Ellipsis")
                {
                    textStyle.TextOverflow = TextOverflow.Ellipsis;
                }
                else if (textOverFlow == "Clip")
                {
                    textStyle.TextOverflow = TextOverflow.Clip;
                }
                else if (textOverFlow == "Wrap")
                {
                    textStyle.TextOverflow = TextOverflow.Wrap;
                }
                break;
        }
    }

    //Update annotation position
    private void UpdatePosition(string id)
    {
        for (int i = 0; i < DiagramInstance!.SelectionSettings!.Nodes!.Count; i++)
        {
            Node node = DiagramInstance.SelectionSettings.Nodes[i] as Node;
            for (int j = 0; j < node.Annotations!.Count; j++)
            {
                DiagramInstance.StartGroupAction();
                ShapeAnnotation annotation = node.Annotations[j] as ShapeAnnotation;
                UpdateAnnotation(id, annotation);
                DiagramInstance.EndGroupAction();
            }
        }
        for (int i = 0; i < DiagramInstance.SelectionSettings.Connectors!.Count; i++)
        {
            Connector node = DiagramInstance.SelectionSettings.Connectors[i] as Connector;
            for (int j = 0; j < node.Annotations!.Count; j++)
            {
                DiagramInstance.StartGroupAction();
                PathAnnotation annotation = node.Annotations[j] as PathAnnotation;
                UpdateAnnotationValue(id, annotation);
                DiagramInstance.EndGroupAction();
            }
        }
    }

    //Update path annotation
    private void UpdateAnnotationValue(string id, PathAnnotation annotation)
    {
        DiagramInstance!.BeginUpdate();
        if (!IsPanelUpdateOnly)
        {
            switch (id)
            {
                case "sourcetext":
                    annotation.Offset = 0;
                    break;
                case "targettext":
                    annotation.Offset = 1;
                    break;
                case "abovecenter":
                    annotation.Offset = 0.5;
                    annotation.Alignment = AnnotationAlignment.After;
                    break;
                case "belowcenter":
                    annotation.Offset = 0.5;
                    annotation.Alignment = AnnotationAlignment.Before;
                    break;
                case "centertext":
                    annotation.Offset = 0.5;
                    annotation.Alignment = AnnotationAlignment.Center;
                    break;
            }
        }
        UpdateSelection(id);
        UpateProprtyPanelValue(annotation);
        _ = DiagramInstance.EndUpdateAsync();
    }

    //Update pathannotation property panel value
    private void UpateProprtyPanelValue(PathAnnotation annotation)
    {
        FontSizeValue = int.Parse(annotation.Style!.FontSize.ToString());
        FontStyle = annotation.Style.FontFamily!;
        FillColor = annotation.Style.Color!;
    }

    //Update shapeannotation alignment
    private void UpdateAnnotation(string id, ShapeAnnotation annotation)
    {
        DiagramInstance!.BeginUpdate();
        if (!IsPanelUpdateOnly)
        {
            switch (id)
            {
                case "left":
                    SetAnnotationPosition(annotation, 0, 0, VerticalAlignment.Top, HorizontalAlignment.Left);
                    break;
                case "right":
                    SetAnnotationPosition(annotation, 1, 0, VerticalAlignment.Top, HorizontalAlignment.Right);
                    break;
                case "bottoml":
                    SetAnnotationPosition(annotation, 0, 1, VerticalAlignment.Bottom, HorizontalAlignment.Left);
                    break;
                case "bottomr":
                    SetAnnotationPosition(annotation, 1, 1, VerticalAlignment.Bottom, HorizontalAlignment.Right);
                    break;
                case "center":
                    SetAnnotationPosition(annotation, 0.5f, 0.5f, VerticalAlignment.Center, HorizontalAlignment.Center);
                    break;
                case "bottomcenter_top":
                    SetAnnotationPosition(annotation, 0.5f, 1, VerticalAlignment.Top, HorizontalAlignment.Center);
                    break;
            }
        }
        UpdateSelection(id);
        UpateProprtyPanel(annotation);
        _ = DiagramInstance.EndUpdateAsync();
    }

    //Update shapeannotation property panel
    private void UpateProprtyPanel(ShapeAnnotation annotation)
    {
        FontSizeValue = int.Parse(annotation.Style!.FontSize.ToString());
        FontStyle = annotation.Style.FontFamily!;
        FillColor = annotation.Style.Color!;
    }

    //Update selection
    private void UpdateSelection(string id)
    {
        for (int i = 0; i < AlignmentOptions.Count; i++)
        {
            var value = AlignmentOptions.Values.ElementAt(i);
            var key = AlignmentOptions.Keys.ElementAt(i);
            if (AlignmentOptions.ContainsKey(id) && key == id)
            {
                value = SelectedItemClass;
            }
            else
            {
                value = UnselectedItemClass;
            }
            AlignmentOptions.Remove(key);
            AlignmentOptions.Add(key, value);
        }
        AlignmentOptions[SelectedPanel] = UnselectedItemClass;
        SelectedPanel = id;
        AlignmentOptions[id] = SelectedItemClass;
    }

    //Set annotation position
    private void SetAnnotationPosition(ShapeAnnotation annotation, float offsetX, float offsetY, VerticalAlignment vAlignment, HorizontalAlignment hAlignment)
    {
        if (annotation.Offset.X != offsetX)
            annotation.Offset.X = offsetX;
        if (annotation.Offset.Y != offsetY)
            annotation.Offset.Y = offsetY;
        annotation.VerticalAlignment = vAlignment;
        annotation.HorizontalAlignment = hAlignment;
        annotation.Margin = new DiagramThickness();
        if (vAlignment == VerticalAlignment.Top && hAlignment == HorizontalAlignment.Left)
        {
            annotation.Margin = new DiagramThickness() { Left = 3, Top = 3 };
        }
        else if (vAlignment == VerticalAlignment.Top && hAlignment == HorizontalAlignment.Right)
        {
            annotation.Margin = new DiagramThickness() { Right = 3, Top = 3 };
        }
        else if (vAlignment == VerticalAlignment.Bottom && hAlignment == HorizontalAlignment.Left)
        {
            annotation.Margin = new DiagramThickness() { Left = 3, Bottom = 3 };

        }
        else if (vAlignment == VerticalAlignment.Bottom && hAlignment == HorizontalAlignment.Right)
        {
            annotation.Margin = new DiagramThickness() { Right = 3, Bottom = 3 };
        }
    }
    @*Hidden:Lines*@
    public class FontFamily
    {
        public string? Name { get; set; }
    }
    private List<FontFamily> FontFamilyLists = new List<FontFamily>() {
        new FontFamily() { Name ="Arial"},
        new FontFamily() { Name ="Aharoni" },
        new FontFamily() { Name ="Bell MT"},
        new FontFamily() { Name = "Fantasy" },
        new FontFamily() { Name ="Times New Roman" },
        new FontFamily() { Name ="Segoe UI" },
        new FontFamily() { Name ="Verdana" },
    };
    public class TextWrapping
    {
        public string? Name { get; set; }
    }
    private List<TextWrapping> TextWrappingList = new List<TextWrapping>() {
        new TextWrapping() { Name ="NoWrap"},
        new TextWrapping() { Name ="Wrap" },
        new TextWrapping() { Name ="WrapWithOverflow"},
    };
    public class TextOverFlow
    {
        public string? Name { get; set; }
    }
    private List<TextOverFlow> TextOverFlowList = new List<TextOverFlow>() {
        new TextOverFlow() { Name ="Ellipsis"},
        new TextOverFlow() { Name ="Wrap" },
        new TextOverFlow() { Name ="Clip"},
    };
    public void Dispose()
    {
        if (DiagramNodes != null)
        {
            DiagramNodes.Clear();
            DiagramNodes = null;
        }
        if (DiagramConnectors != null)
        {
            DiagramConnectors.Clear();
            DiagramConnectors = null;
        }
    }
    @*End:Hidden*@
}
