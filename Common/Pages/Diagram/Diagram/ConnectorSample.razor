@page "/diagram/connectors"

@using Syncfusion.Blazor.Diagram
@using System.Collections.ObjectModel
@*Hidden:Lines*@
@inherits SampleBaseComponent
@implements IDisposable
@*End:Hidden*@
@using Syncfusion.Blazor.Buttons
@using Syncfusion.Blazor.DropDowns
@using NodeShapes = Syncfusion.Blazor.Diagram.NodeShapes
@using SelectionChangedEventArgs = Syncfusion.Blazor.Diagram.SelectionChangedEventArgs
@using ButtonChangeArgs = Syncfusion.Blazor.Buttons.ChangeEventArgs<bool>

@*Hidden:Lines*@
<SampleDescription>
    <p>This sample illustrates the flow of data in a marketing process created using a <code><a target="_blank" href="https://help.syncfusion.com/cr/blazor/Syncfusion.Blazor.Diagram.Connector.html" aria-label="Connector">Connector</a></code>. Different types of connectors and decorators are used to customize the appearance, path, and direction of the data flow.</p>
</SampleDescription>
<ActionDescription>
    <p>In this example, you can see how to add connectors to connect shapes and customize their appearance. A collection of connectors is added to a diagram using the <code><a target="_blank" href="https://help.syncfusion.com/cr/blazor/Syncfusion.Blazor.Diagram.SfDiagramComponent.html#Syncfusion_Blazor_Diagram_SfDiagramComponent_Connectors" aria-label="Connectors">Connectors</a></code> property of the <code><a target="_blank" href="https://help.syncfusion.com/cr/blazor/Syncfusion.Blazor.Diagram.SfDiagramComponent.html" aria-label="SfDiagramComponent">SfDiagramComponent</a></code>. You can use the <code><a target="_blank" href="https://help.syncfusion.com/cr/blazor/Syncfusion.Blazor.Diagram.Connector.html#Syncfusion_Blazor_Diagram_Connector_Style" aria-label="Style">Style</a></code> property to customize its stroke style and the <code><a target="_blank" href="https://help.syncfusion.com/cr/blazor/Syncfusion.Blazor.Diagram.Connector.html#Syncfusion_Blazor_Diagram_Connector_CornerRadius" aria-label="CornerRadius">CornerRadius</a></code> property to add rounded corners to connectors. The <code><a target="_blank" href="https://help.syncfusion.com/cr/blazor/Syncfusion.Blazor.Diagram.SegmentThumbSettings.html#Syncfusion_Blazor_Diagram_SegmentThumbSettings_Shape" aria-label="Shape">Shape</a></code> property of <code><a target="_blank" href="https://help.syncfusion.com/cr/blazor/Syncfusion.Blazor.Diagram.Connector.html#Syncfusion_Blazor_Diagram_Connector_SegmentThumbSettings" aria-label="SegmentThumbSettings">SegmentThumbSettings</a></code> customizes the appearance of the segment shape for both Orthogonal and Bezier connectors.</p>
    <p>Click different styles in the properties panel to customize the appearance of the connector. The <code>Lock</code> option enables or disables connector editing.</p>
</ActionDescription>
@*End:Hidden*@

<div class="col-lg-9 control-section sb-property-border">
    <div id="diagram-space" class="content-wrapper">
        <SfDiagramComponent @ref="@DiagramInstance"
                            SelectionSettings="@selectionSettings"
                            ConnectorCreating="@ConnectorCreating"
                            SetNodeTemplate="@SetNodeContent"
                            Height="650px"
                            Nodes="@DiagramNodes"
                            Created="OnCreated"
                            SelectionChanged="@SelectionChanged"
                            Connectors="@DiagramConnectors">
            <SnapSettings>
                <HorizontalGridLines LineColor="#e0e0e0 " LineIntervals="@GridLineIntervals">
                </HorizontalGridLines>
                <VerticalGridLines LineColor="#e0e0e0" LineIntervals="@GridLineIntervals">
                </VerticalGridLines>
            </SnapSettings>
        </SfDiagramComponent>       
    </div>
</div>

@*Hidden:Lines*@
<div class="col-lg-3 property-section">
    <style>
        .image-pattern-style {
            background-color: white;
            background-size: contain;
            background-repeat: no-repeat;
            height: 45px;
            width: calc((100% - 13px) / 3);
            cursor: pointer;
            border: 1px solid #D5D5D5;
            background-position: center;
            float: left;
        }

            .image-pattern-style:hover {
                border-color: gray;
                border-width: 2px;
            }

        .row {
            margin-left: 0px;
            margin-right: 0px;
        }

        .sb-child-row {
            padding-top: 8px;
        }

        .row-header {
            font-size: 13px;
            font-weight: 600;
        }

        .e-radio + label .e-label {
            display: inline-block;
            font-family: "Helvetica Neue", "Helvetica", "Arial", sans-serif, "-apple-system", "BlinkMacSystemFont";
            font-size: 12px;
            font-weight: normal;
            line-height: 1;
            padding-left: 24px;
            vertical-align: text-top;
            white-space: normal;
            padding-top:2px;
        }

        .e-selected-style {
            border-color: #006CE6;
            border-width: 2px;
        }

        .e-checkbox-wrapper .e-label {
            font-size: 12px;
        }

        .row {
            display: block;
        }
    </style>

    <div class="property-panel-header">
        Properties
    </div>
    <div class="row row-header">
        Apply To
    </div>
    <div class="row" style="padding-top: 8px">
        <SfRadioButton Label="All Connectors" Name="NodeSelection" Value=@AllShapes @bind-Checked="@SelectedShapeOption" TChecked="string"></SfRadioButton>

    </div>
    <div class="row" style="padding-top: 8px">
        <SfRadioButton Label="Selected Connector" Name="NodeSelection" Value=@SelectedShapes @bind-Checked="@SelectedShapeOption" TChecked="string"></SfRadioButton>
    </div>
    <div class="row row-header" style="padding-top: 10px;">Appearance</div>
    <div class="row" style="padding-top: 8px">
        <div class="@CssClass!["Straight"]" @onclick="@(() => ChangeConnectorAppearance("Straight"))" style="background-image: url(@(SampleService!.WebAssetsPath + "images/diagram/connector/straight.png")); margin-right: 3px">
        </div>
        <div class="@CssClass["Orthogonal"]" @onclick="@(() => ChangeConnectorAppearance("Orthogonal"))" style="background-image: url(@(SampleService.WebAssetsPath + "images/diagram/connector/orthogonal.png")); margin: 0px 3px">
        </div>
        <div class="@CssClass["Bezier"]" @onclick="@(() => ChangeConnectorAppearance("Bezier"))" style="background-image: url(@(SampleService.WebAssetsPath + "images/diagram/connector/bezier.png")); margin-left: 3px">
        </div>
    </div>
    <div class="row" style="padding-top: 8px">
        <div class="@CssClass["StraightWithStroke"]" @onclick="@(() => ChangeConnectorAppearance("StraightWithStroke"))" style="background-image: url(@(SampleService.WebAssetsPath + "images/diagram/connector/straight-with-stroke.png")); margin-right: 3px">
        </div>
        <div class="@CssClass["OrthogonalWithStroke"]" @onclick="@(() => ChangeConnectorAppearance("OrthogonalWithStroke"))" style="background-image: url(@(SampleService.WebAssetsPath + "images/diagram/connector/orthogonal-with-stroke.png")); margin: 0px 3px">
        </div>
        <div class="@CssClass["BezierWithStroke"]" @onclick="@(() => ChangeConnectorAppearance("BezierWithStroke"))" style="background-image: url(@(SampleService.WebAssetsPath + "images/diagram/connector/bezier-with-stroke.png")); margin-left: 3px">
        </div>
    </div>
    <div class="row" style="padding-top: 8px">
        <div class="@CssClass["StraightWithDashArray"]" @onclick="@(() => ChangeConnectorAppearance("StraightWithDashArray"))" style="background-image: url(@(SampleService.WebAssetsPath + "images/diagram/connector/straight-with-dash-array.png")); margin-right: 3px">
        </div>
        <div class="@CssClass["OrthogonalWithDashArray"]" @onclick="@(() => ChangeConnectorAppearance("OrthogonalWithDashArray"))" style="background-image: url(@(SampleService.WebAssetsPath + "images/diagram/connector/orthogonal-with-dash-array.png")); margin: 0px 3px">
        </div>
        <div class="@CssClass["BezierWithDashArray"]" @onclick="@(() => ChangeConnectorAppearance("BezierWithDashArray"))" style="background-image: url(@(SampleService.WebAssetsPath + "images/diagram/connector/bezier-with-dash-array.png")); margin-left: 3px">
        </div>
    </div>
    <div class="row" style="padding-top: 8px">
        <div class="@CssClass["CornerRadious"]" @onclick="@(() => ChangeConnectorAppearance("CornerRadious"))" style="background-image: url(@(SampleService.WebAssetsPath + "images/diagram/connector/corner-radius.png")); margin-right: 3px">
        </div>
        <div class="@CssClass["SourceDecorator"]" @onclick="@(() => ChangeConnectorAppearance("SourceDecorator"))" style="background-image: url(@(SampleService.WebAssetsPath + "images/diagram/connector/source-decorator.png")); margin: 0px 3px">
        </div>
        <div class="@CssClass["SourceDecoratorWithDashArray"]" @onclick="@(() => ChangeConnectorAppearance("SourceDecoratorWithDashArray"))" style="background-image: url(@(SampleService.WebAssetsPath + "images/diagram/connector/source-decorator-with-dash-array.png")); margin-left: 3px">
        </div>
    </div>
    <div class="row property-panel-content" style="padding-top: 10px">
        <div class="row row-header">
            Behavior
        </div>
        <div class="row" style="padding-top: 8px">
            <SfCheckBox Label="Lock" Checked="@IsChecked" ValueChange="@ConstraintsChange" TChecked="bool" />
        </div>
    </div>
    <div class="row property-panel-content" style="padding-top: 10px">
        <div class="row row-header">
            Source Decorators
        </div>
        <div class="row" style="padding-top: 8px">
            <SfDropDownList ID="SourceDecorator" TValue="string" TItem="DiagramShapeModel" @bind-Value="@SourceDecoratorShape" PopupHeight="150" DataSource="shape" Placeholder="Select a Shape">
                <DropDownListFieldSettings Text="Text" Value="Value"></DropDownListFieldSettings>
                <DropDownListEvents TValue="string" TItem="DiagramShapeModel" ValueChange="OnSourceDecoratorChange"></DropDownListEvents>
            </SfDropDownList>
        </div>
    </div>
    <div class="row property-panel-content" style="padding-top: 10px">
        <div class="row row-header">
            Target Decorators
        </div>
        <div class="row" style="padding-top: 8px">
            <SfDropDownList ID="TargetDecorator" TValue="string" TItem="DiagramShapeModel" @bind-Value="@SelectedTargetDecorator" PopupHeight="120" DataSource="shape" Placeholder="Select a Shape">
                <DropDownListFieldSettings Text="Text" Value="Value"></DropDownListFieldSettings>
                <DropDownListEvents TValue="string" TItem="DiagramShapeModel" ValueChange="OnTargetDecoratorChange"></DropDownListEvents>
            </SfDropDownList>
        </div>
    </div>
    <div class="row property-panel-content" style="padding-top: 10px">
        <div class="row row-header">
            Segment Shape
        </div>
        <div class="row" style="padding-top: 8px">
            <SfDropDownList ID="SegmentShape" TValue="string" TItem="DiagramShapeModel" PopupHeight="120" DataSource="segmentShape" Placeholder="Circle" @bind-Value="@ThumbShape">
                <DropDownListFieldSettings Text="Text" Value="Value"></DropDownListFieldSettings>
                <DropDownListEvents TValue="string" TItem="DiagramShapeModel" ValueChange="OnSegmentShapeChange"></DropDownListEvents>
            </SfDropDownList>
        </div>
    </div>
    
</div>
@*End:Hidden*@

@code
{
    public DiagramSelectionSettings selectionSettings = new DiagramSelectionSettings();
    @*Hidden:Lines*@
    private string SelectedShapeOption { get; set; } = "All shapes";
    private string AllShapes { get; set; } = "All shapes";
    private string SelectedShapes { get; set; } = "Selected Shapes";
    bool IsChecked { get; set; } = false;
    const string DefaultCssClass = "image-pattern-style";
    const string SelectedCssClass = "image-pattern-style e-selected-style";
    public int DiagramConnectorCount { get; set; }
    public string SourceDecoratorShape { get; set; } = "None";
    public string SelectedTargetDecorator { get; set; } = "Arrow";
    public string SelectedConnectorType { get; set; } = "Bezier";
    public string ThumbShape { get; set; } = "Circle";
    public Dictionary<string, string>? CssClass { get; set; }

    @*End:Hidden*@
    SfDiagramComponent? DiagramInstance { get; set; }
    // Defines interval values for GridLines
    public double[]? GridLineIntervals { get; set; }

    //Defines diagram's nodes collection
    DiagramObjectCollection<Node>? DiagramNodes { get; set; } = new DiagramObjectCollection<Node>();

    //Defines diagram's connectors collection
    DiagramObjectCollection<Connector>? DiagramConnectors { get; set; } = new DiagramObjectCollection<Connector>();

    @*Hidden:Lines*@
    private void OnCreated()
    {
        FitOptions mobileoptions = new FitOptions() { Mode = FitMode.Both, Region = DiagramRegion.Content };
        DiagramInstance!.FitToPage(mobileoptions);
    }
    @*Hidden:Lines*@
    List<DiagramShapeModel> shape = new List<DiagramShapeModel>()
    {
        new DiagramShapeModel() { Value = "Arrow", Text = "Arrow" },
        new DiagramShapeModel() { Value = "None", Text = "None" },
        new DiagramShapeModel() { Value = "OpenFletch", Text = "Open Fletch" },
        new DiagramShapeModel() { Value = "DimensionLine", Text = "Dimension Line" },
        new DiagramShapeModel() { Value = "ClosedSharp", Text = "Closed Sharp" },
        new DiagramShapeModel() { Value = "IndentedClosed", Text = "Indented Closed"},
        new DiagramShapeModel() { Value = "OutdentedClosed", Text = "Outdented Closed"},
        new DiagramShapeModel() { Value = "ClosedFlench", Text = "Closed Flench"},
        new DiagramShapeModel() { Value = "BackSlash", Text = "Back Slash"},
        new DiagramShapeModel() { Value = "Diamond", Text = "Diamond"},
        new DiagramShapeModel() { Value = "Ellipse", Text = "Ellipse"},
        new DiagramShapeModel() { Value = "Rectangle", Text = "Rectangle"},
        new DiagramShapeModel() { Value = "ClosedDouble", Text = "Closed Double"},
    };

    List<DiagramShapeModel> segmentShape = new List<DiagramShapeModel>()
    {
     new DiagramShapeModel() { Value = "Arrow", Text = "Arrow" },
     new DiagramShapeModel() { Value = "Circle", Text = "Circle" },
     new DiagramShapeModel() { Value = "Diamond", Text = "Diamond" },
     new DiagramShapeModel() { Value = "DoubleArrow", Text = "DoubleArrow" },
     new DiagramShapeModel() { Value = "Fletch", Text = "Fletch" },
     new DiagramShapeModel() { Value = "IndentedArrow", Text = "IndentedArrow"},
     new DiagramShapeModel() { Value = "OpenArrow", Text = "OpenArrow"},
     new DiagramShapeModel() { Value = "OpenFetch", Text = "OpenFetch"},
     new DiagramShapeModel() { Value = "OutdentedArrow", Text = "OutdentedArrow"},
     new DiagramShapeModel() { Value = "Rhombus", Text = "Rhombus"},
     new DiagramShapeModel() { Value = "Square", Text = "Square"},
     new DiagramShapeModel() { Value = "Rectangle", Text = "Rectangle"},
     new DiagramShapeModel() { Value = "Ellipse", Text = "Ellipse"},
     };

    //Method to update the source decorator style
    private async Task OnSourceDecoratorChange(ChangeEventArgs<string, DiagramShapeModel> args)
    {
        DiagramInstance!.StartGroupAction();
        DiagramInstance.BeginUpdate();
        if (SelectedShapeOption == "All shapes")
        {
            for (int i = 0; i < DiagramInstance.Connectors!.Count; i++)
            {
                this.UpdateSourceDecoratorShape(args, DiagramInstance.Connectors[i]);
            }
        }
        if (SelectedShapeOption == "Selected Shapes" && DiagramInstance.SelectionSettings!.Connectors!.Count > 0)
        {
            for (var i = 0; i < DiagramInstance.SelectionSettings.Connectors.Count; i++)
            {
                Connector selectedConnector = DiagramInstance.SelectionSettings.Connectors[i] as Connector;
                this.UpdateSourceDecoratorShape(args, selectedConnector);
            }
        };
        await DiagramInstance.EndUpdateAsync();
        DiagramInstance.EndGroupAction();
    }

    //Method to update the target decorator style
    private async Task OnTargetDecoratorChange(ChangeEventArgs<string, DiagramShapeModel> args)
    {
        DiagramInstance!.StartGroupAction();
        DiagramInstance.BeginUpdate();
        if (SelectedShapeOption == "All shapes")
        {
            for (int i = 0; i < DiagramInstance.Connectors!.Count; i++)
            {
                this.UpdateTargetDecoratorShape(args, DiagramInstance.Connectors[i]);
            }
        }
        if (SelectedShapeOption == "Selected Shapes" && DiagramInstance.SelectionSettings!.Connectors!.Count > 0)
        {
            for (var i = 0; i < DiagramInstance.SelectionSettings.Connectors.Count; i++)
            {
                Connector selectedConnector = DiagramInstance.SelectionSettings.Connectors[i] as Connector;
                this.UpdateTargetDecoratorShape(args, selectedConnector);
            }
        };
        await DiagramInstance.EndUpdateAsync();
        DiagramInstance.EndGroupAction();
    }
    private void UpdateSourceDecoratorShape(ChangeEventArgs<string, DiagramShapeModel> args, Connector connector)
    {
        switch (args.Value)
        {
            case "Arrow":
                connector.SourceDecorator!.Shape = DecoratorShape.Arrow;
                break;
            case "None":
                connector.SourceDecorator!.Shape = DecoratorShape.None;
                break;
            case "Diamond":
                connector.SourceDecorator!.Shape = DecoratorShape.Diamond;
                break;
            case "Ellipse":
                connector.SourceDecorator!.Shape = DecoratorShape.Circle;
                break;
            case "Rectangle":
                connector.SourceDecorator!.Shape = DecoratorShape.Square;
                break;
            case "OpenFletch":
                connector.SourceDecorator!.Shape = DecoratorShape.OpenFletch;
                break;
            case "DimensionLine":
                connector.SourceDecorator!.Shape = DecoratorShape.Custom;
                connector.SourceDecorator.PathData = "M230.5,994.5L241.5,980.5";
                break;
            case "ClosedSharp":
                connector.SourceDecorator!.Shape = DecoratorShape.Custom;
                connector.SourceDecorator.PathData = "M360.5,228.5L371.5,234.5L360.5,240.5L360.5,228.5z";
                break;
            case "IndentedClosed":
                connector.SourceDecorator!.Shape = DecoratorShape.Custom;
                connector.SourceDecorator.PathData = "M374.5,284.5L361.5,290.5C363.548,286.723,363.548,282.277,361.5,278.5L374.5,284.5z";
                break;
            case "OutdentedClosed":
                connector.SourceDecorator!.Shape = DecoratorShape.Custom;
                connector.SourceDecorator.PathData = "M361.7583,333.5L373.4953,339.287L361.9823,345.5C360.0823,341.756,359.9993,337.311,361.7583,333.5z";
                break;
            case "ClosedFlench":
                connector.SourceDecorator!.Shape = DecoratorShape.Custom;
                connector.SourceDecorator.PathData = "M357.5,394.5C360.569,390.723,365.387,388.5,370.5,388.5C365.387,388.5,360.569,386.277,357.5,382.5C359.909,386.133,359.909,390.867,357.5,394.5z";
                break;
            case "BackSlash":
                connector.SourceDecorator!.Shape = DecoratorShape.Custom;
                connector.SourceDecorator.PathData = "M364.2808,602.5L351.3318,590.5";
                break;
            case "ClosedDouble":
                connector.SourceDecorator!.Shape = DecoratorShape.Custom;
                connector.SourceDecorator.PathData = "M10.5,0.5 L19.493982,4.9999999 10.5,9.4999999 z M0.5,0.5 L9.4939995,4.9999999 0.5,9.4999999 z";
                break;
        }
    }
    private void UpdateTargetDecoratorShape(ChangeEventArgs<string, DiagramShapeModel> args, Connector connector)
    {
            switch (args.Value)
            {
                case "Arrow":
                    connector.TargetDecorator!.Shape = DecoratorShape.Arrow;
                    break;
                case "None":
                    connector.TargetDecorator!.Shape = DecoratorShape.None;
                    break;
                case "Diamond":
                    connector.TargetDecorator!.Shape = DecoratorShape.Diamond;
                    break;
                case "Ellipse":
                    connector.TargetDecorator!.Shape = DecoratorShape.Circle;
                    break;
                case "Rectangle":
                    connector.TargetDecorator!.Shape = DecoratorShape.Square;
                    break;
                case "OpenFletch":
                    connector.TargetDecorator!.Shape = DecoratorShape.OpenFletch;
                    break;
                case "DimensionLine":
                    connector.TargetDecorator!.Shape = DecoratorShape.Custom;
                    connector.TargetDecorator.PathData = "M230.5,994.5L241.5,980.5";
                    break;
                case "ClosedSharp":
                    connector.TargetDecorator!.Shape = DecoratorShape.Custom;
                    connector.TargetDecorator.PathData = "M360.5,228.5L371.5,234.5L360.5,240.5L360.5,228.5z";
                    break;
                case "IndentedClosed":
                    connector.TargetDecorator!.Shape = DecoratorShape.Custom;
                    connector.TargetDecorator.PathData = "M374.5,284.5L361.5,290.5C363.548,286.723,363.548,282.277,361.5,278.5L374.5,284.5z";
                    break;
                case "OutdentedClosed":
                    connector.TargetDecorator!.Shape = DecoratorShape.Custom;
                    connector.TargetDecorator.PathData = "M361.7583,333.5L373.4953,339.287L361.9823,345.5C360.0823,341.756,359.9993,337.311,361.7583,333.5z";
                    break;
                case "ClosedFlench":
                    connector.TargetDecorator!.Shape = DecoratorShape.Custom;
                    connector.TargetDecorator.PathData = "M357.5,394.5C360.569,390.723,365.387,388.5,370.5,388.5C365.387,388.5,360.569,386.277,357.5,382.5C359.909,386.133,359.909,390.867,357.5,394.5z";
                    break;
                case "BackSlash":
                    connector.TargetDecorator!.Shape = DecoratorShape.Custom;
                    connector.TargetDecorator.PathData = "M364.2808,602.5L351.3318,590.5";
                    break;
                case "ClosedDouble":
                    connector.TargetDecorator!.Shape = DecoratorShape.Custom;
                    connector.TargetDecorator.PathData = "M10.5,0.5 L19.493982,4.9999999 10.5,9.4999999 z M0.5,0.5 L9.4939995,4.9999999 0.5,9.4999999 z";
                    break;
            }
    }
    public class DiagramShapeModel
    {
        public string? Value { get; set; }
        public string? Text { get; set; }
    }
    @*End:Hidden*@

    protected override void OnInitialized()
    {
        
        GridLineIntervals = new double[]{ 1, 9, 0.25, 9.75, 0.25, 9.75, 0.25, 9.75, 0.25, 9.75, 0.25, 9.75, 0.25, 9.75, 0.25, 9.75, 0.25, 9.75, 0.25, 9.75 };
        selectionSettings.Constraints = (SelectorConstraints.ConnectorSourceThumb | SelectorConstraints.ConnectorTargetThumb);
        @*Hidden:Lines*@
        CssClass = new Dictionary<string, string>()
        {
            { "Straight", DefaultCssClass },
            { "Orthogonal", DefaultCssClass },
            { "Bezier", DefaultCssClass },
            { "StraightWithStroke", DefaultCssClass },
            { "OrthogonalWithStroke", DefaultCssClass },
            { "BezierWithStroke", SelectedCssClass },
            { "StraightWithDashArray", DefaultCssClass },
            { "OrthogonalWithDashArray", DefaultCssClass },
            { "BezierWithDashArray", DefaultCssClass },
            { "CornerRadious", DefaultCssClass },
            { "SourceDecorator", DefaultCssClass },
            { "SourceDecoratorWithDashArray", DefaultCssClass },
        };
        @*End:Hidden*@

        // Creating ports for node
        var port1 = CreatePort("port1", 1, .25);
        var port2 = CreatePort("port2", 1, .5);
        var port3 = CreatePort("port3", 1, .75);
        var ports1 = new DiagramObjectCollection<PointPort>() { port1, port2, port3 };
        var port4 = CreatePort("port4", 0, 0.46);
        var port5 = CreatePort("port5", 0, 0.5);
        var port6 = CreatePort("port6", 0, 0.54);
        var ports6 = new DiagramObjectCollection<PointPort>() { port4, port5, port6 };
        var inPort = CreatePort("inPort", 0, 0.5);
        var outPort = CreatePort("outPort", 1, 0.5);
        var ports3 = new DiagramObjectCollection<PointPort>() { inPort, outPort };
        var ports4 = new DiagramObjectCollection<PointPort>() { inPort, outPort };
        var ports5 = new DiagramObjectCollection<PointPort>() { inPort, outPort };
        var ports2 = new DiagramObjectCollection<PointPort>() { inPort, outPort };

        // Creating Node
        Node stackNode = new Node();
        stackNode.ID = "stackNode";
        stackNode.OffsetX = 510;
        stackNode.OffsetY = 302;
        stackNode.Ports = new DiagramObjectCollection<PointPort>() { port4, port5, port6 };
        DiagramNodes!.Add(stackNode);

        CreateNode("Promotion", 50, 302, "Promotion");
        CreateNode("Lead", 180, 302, "Lead", ports1);
        CreateNode("Account", 340, 239, "Account", ports2);
        CreateNode("Information", 340, 302, "Information", ports3);
        CreateNode("Opportunity", 340, 364, "Opportunity", ports4);

        DiagramConnectors = new DiagramObjectCollection<Connector>();
        // Creating Connector
        CreateConnector("Promotion", "Lead", null, null);
        CreateConnector("Lead", "Account", "port1", "inPort");
        CreateConnector("Lead", "Information", "port2", "inPort");
        CreateConnector("Lead", "Opportunity", "port3", "inPort");
        CreateConnector("stackNode", "Account", "port4", "outPort");
        CreateConnector("stackNode", "Information", "port5", "outPort");
        CreateConnector("stackNode", "Opportunity", "port6", "outPort");
    }

    // Method to update node style in common
    private CommonElement? SetNodeContent(IDiagramObject node)
    {
        Node? templateNode = node as Node;

        if (templateNode!.ID == "stackNode")
        {
            StackPanel column1 = CreateStackPanelNode("Events");
            StackPanel column2 = CreateStackPanelNode("Emails");
            StackPanel column3 = CreateStackPanelNode("Calls");
            StackPanel column4 = CreateStackPanelNode("Smart contents");

            StackPanel table = new StackPanel();
            table.Style = new ShapeStyle() { Fill = "#e6e0eb", StrokeColor = "#6F409F", StrokeWidth = 2 };
            table.Orientation = Orientation.Vertical;
            table.Children = new ObservableCollection<CommonElement>() { column1, column2, column3, column4 };
            return table;
        }
        else
        {
            templateNode.Style = new ShapeStyle() { StrokeColor = "#6F409F", StrokeWidth = 2 };
            templateNode.Shape = new BasicShape() { Type = NodeShapes.Basic, Shape = NodeBasicShapes.Rectangle, CornerRadius = 10 };
        }
        return null;
    }

    // Method to create stackpanel node
    private StackPanel CreateStackPanelNode(string text)
    {
        return new StackPanel()
        {
            Style = new ShapeStyle() { Fill = "#6F409F", StrokeColor = "#6F409F" },
            Margin = new DiagramThickness() { Bottom = 10, Left = 10, Right = 10, Top = 10 },
            Padding = new DiagramThickness() { Bottom = 10, Left = 10, Right = 10, Top = 10 },
            Children = new ObservableCollection<CommonElement>() { GetTextElement(text) }
        };
    }

    // Method to update text for stackpanel node
    private TextElement GetTextElement(string text)
    {
        var textElement = new TextElement();
        textElement.Width = 60;
        textElement.Height = 20;
        textElement.Content = text;
        textElement.Style = new TextStyle() { Color = "white" };
        return textElement;
    }

    @*Hidden:Lines*@
    private void SelectionChanged(SelectionChangedEventArgs arg)
    {
        if (arg.NewValue != null && arg.NewValue.Count > 0)
        {
            if (arg.NewValue[0] is Connector)
            {
                Connector? connector = null;
                if (arg.NewValue[0] != null && arg.NewValue.Count > 0)
                {
                    connector = arg.NewValue[0] as Connector;
                }
                if (connector != null)
                {
                    if (connector.Constraints == (connector.Constraints | ConnectorConstraints.Default & ~(ConnectorConstraints.ReadOnly)))
                    {
                        IsChecked = false;
                    }
                    else
                    {
                        IsChecked = true;
                    }

                    CssClass = new Dictionary<string, string>()
                    {
                        { "Straight", DefaultCssClass },
                        { "Orthogonal", DefaultCssClass },
                        { "Bezier", DefaultCssClass },
                        { "StraightWithStroke", DefaultCssClass },
                        { "OrthogonalWithStroke", DefaultCssClass },
                        { "BezierWithStroke", DefaultCssClass },
                        { "StraightWithDashArray", DefaultCssClass },
                        { "OrthogonalWithDashArray", DefaultCssClass },
                        { "BezierWithDashArray", DefaultCssClass },
                        { "CornerRadious", DefaultCssClass },
                        { "SourceDecorator", DefaultCssClass },
                        { "SourceDecoratorWithDashArray", DefaultCssClass },
                    };

                    if (connector.Style!.StrokeDashArray != "5,5" && connector.SourceDecorator!.Shape == DecoratorShape.None)
                    {
                        if (connector.Type == ConnectorSegmentType.Straight && connector.Style.StrokeWidth == 1)
                        {
                            UpdateSelection("Straight");
                        }
                        else if (connector.Type == ConnectorSegmentType.Orthogonal && connector.CornerRadius == 5)
                        {
                            UpdateSelection("CornerRadious");
                        }
                        else if (connector.Type == ConnectorSegmentType.Orthogonal && connector.SourceDecorator.Shape == DecoratorShape.Circle && connector.Style.StrokeDashArray == "5,5")
                        {
                            UpdateSelection("SourceDecoratorWithDashArray");
                        }
                        else if (connector.Type == ConnectorSegmentType.Orthogonal && connector.SourceDecorator.Shape == DecoratorShape.Circle)
                        {
                            UpdateSelection("SourceDecorator");
                        }
                        else if (connector.Type == ConnectorSegmentType.Orthogonal && connector.Style.StrokeWidth == 1)
                        {
                            UpdateSelection("Orthogonal");
                        }
                        else if (connector.Type == ConnectorSegmentType.Bezier && connector.Style.StrokeWidth == 1)
                        {
                            UpdateSelection("Bezier");
                        }
                        else if (connector.Type == ConnectorSegmentType.Straight && connector.Style.StrokeWidth == 2)
                        {
                            UpdateSelection("StraightWithStroke");
                        }
                        else if (connector.Type == ConnectorSegmentType.Orthogonal && connector.Style.StrokeWidth == 2)
                        {
                            UpdateSelection("OrthogonalWithStroke");
                        }
                        else if (connector.Type == ConnectorSegmentType.Bezier && connector.Style.StrokeWidth == 2)
                        {
                            UpdateSelection("BezierWithStroke");
                        }
                    }
                    if (connector.Style.StrokeDashArray == "5,5" && connector.SourceDecorator!.Shape == DecoratorShape.None)
                    {
                        if (connector.Type == ConnectorSegmentType.Straight)
                        {
                            UpdateSelection("StraightWithDashArray");
                        }
                        else if (connector.Type == ConnectorSegmentType.Orthogonal)
                        {
                            UpdateSelection("OrthogonalWithDashArray");
                        }
                        else if (connector.Type == ConnectorSegmentType.Bezier)
                        {
                            UpdateSelection("BezierWithDashArray");
                        }
                    }

                    if (connector.SourceDecorator!.Shape == DecoratorShape.Circle)
                    {
                        if (connector.Style.StrokeDashArray == "5,5")
                        {
                            UpdateSelection("SourceDecoratorWithDashArray");

                        }
                        else
                        {
                            UpdateSelection("SourceDecorator");
                        }
                    }
                    ThumbShape = connector.SegmentThumbSettings.Shape.ToString(); 
                    SourceDecoratorShape = connector.SourceDecorator.Shape.ToString();
                    SelectedTargetDecorator = connector.TargetDecorator!.Shape.ToString();
                    if (SourceDecoratorShape == "Custom")
                    {
                        switch (connector.SourceDecorator.PathData)
                        {
                            case "M230.5,994.5L241.5,980.5" :
                                SourceDecoratorShape = "DimensionLine";
                                break;
                            case "M360.5,228.5L371.5,234.5L360.5,240.5L360.5,228.5z":
                                SourceDecoratorShape = "ClosedSharp";
                                break;
                            case "M374.5,284.5L361.5,290.5C363.548,286.723,363.548,282.277,361.5,278.5L374.5,284.5z" :
                                SourceDecoratorShape = "IndentedClosed";
                                break;
                            case "M361.7583,333.5L373.4953,339.287L361.9823,345.5C360.0823,341.756,359.9993,337.311,361.7583,333.5z" :
                                SourceDecoratorShape = "OutdentedClosed";
                                break;
                            case "M357.5,394.5C360.569,390.723,365.387,388.5,370.5,388.5C365.387,388.5,360.569,386.277,357.5,382.5C359.909,386.133,359.909,390.867,357.5,394.5z" :
                                SourceDecoratorShape = "ClosedFlench";
                                break;
                            case "M364.2808,602.5L351.3318,590.5":
                                SourceDecoratorShape = "BackSlash";
                                break;
                            case "M10.5,0.5 L19.493982,4.9999999 10.5,9.4999999 z M0.5,0.5 L9.4939995,4.9999999 0.5,9.4999999 z" :
                                SourceDecoratorShape = "ClosedDouble";
                                break;
                        }
                    }
                    if (SelectedTargetDecorator == "Custom")
                    {
                        switch (connector.TargetDecorator.PathData)
                        {
                            case "M230.5,994.5L241.5,980.5":
                                SelectedTargetDecorator = "DimensionLine";
                                break;
                            case "M360.5,228.5L371.5,234.5L360.5,240.5L360.5,228.5z":
                                SelectedTargetDecorator = "ClosedSharp";
                                break;
                            case "M374.5,284.5L361.5,290.5C363.548,286.723,363.548,282.277,361.5,278.5L374.5,284.5z":
                                SelectedTargetDecorator = "IndentedClosed";
                                break;
                            case "M361.7583,333.5L373.4953,339.287L361.9823,345.5C360.0823,341.756,359.9993,337.311,361.7583,333.5z":
                                SelectedTargetDecorator = "OutdentedClosed";
                                break;
                            case "M357.5,394.5C360.569,390.723,365.387,388.5,370.5,388.5C365.387,388.5,360.569,386.277,357.5,382.5C359.909,386.133,359.909,390.867,357.5,394.5z":
                                SelectedTargetDecorator = "ClosedFlench";
                                break;
                            case "M364.2808,602.5L351.3318,590.5":
                                SelectedTargetDecorator = "BackSlash";
                                break;
                            case "M10.5,0.5 L19.493982,4.9999999 10.5,9.4999999 z M0.5,0.5 L9.4939995,4.9999999 0.5,9.4999999 z":
                                SelectedTargetDecorator = "ClosedDouble";
                                break;
                        }
                    }
                }
            }
        }
    }

    private void UpdateSelection(string id)
    {
        for (int i = 0; i < CssClass!.Count; i++)
        {
            var value = CssClass.Values.ElementAt(i);
            var key = CssClass.Keys.ElementAt(i);
            if (CssClass.ContainsKey(id) && key == id)
            {
                value = SelectedCssClass;
            }
            else
            {
                value = DefaultCssClass;
            }
            CssClass.Remove(key);
            CssClass.Add(key, value);
        }
    }

    public void ChangeConnectorAppearance(string typeSelected)
    {
        CssClass = new Dictionary<string, string>()
        {
            { "Straight", DefaultCssClass},
            { "Orthogonal", DefaultCssClass },
            { "Bezier", DefaultCssClass },
            { "StraightWithStroke", DefaultCssClass },
            { "OrthogonalWithStroke", DefaultCssClass },
            { "BezierWithStroke", DefaultCssClass },
            { "StraightWithDashArray", DefaultCssClass },
            { "OrthogonalWithDashArray", DefaultCssClass },
            { "BezierWithDashArray", DefaultCssClass },
            { "CornerRadious", DefaultCssClass },
            { "SourceDecorator", DefaultCssClass },
            { "SourceDecoratorWithDashArray", DefaultCssClass },
        };

        switch (typeSelected)
        {
            case "Straight":
                ApplyStyle(ConnectorSegmentType.Straight, 1);
                break;
            case "Orthogonal":
                ApplyStyle(ConnectorSegmentType.Orthogonal, 1);
                break;
            case "Bezier":
                ApplyStyle(ConnectorSegmentType.Bezier, 1);
                break;
            case "StraightWithStroke":
                ApplyStyle(ConnectorSegmentType.Straight, 2);
                break;
            case "OrthogonalWithStroke":
                ApplyStyle(ConnectorSegmentType.Orthogonal, 2);
                break;
            case "BezierWithStroke":
                ApplyStyle(ConnectorSegmentType.Bezier, 2);
                break;
            case "StraightWithDashArray":
                ApplyStyle(ConnectorSegmentType.Straight, 2, true);
                break;
            case "OrthogonalWithDashArray":
                ApplyStyle(ConnectorSegmentType.Orthogonal, 2, true);
                break;
            case "BezierWithDashArray":
                ApplyStyle(ConnectorSegmentType.Bezier, 2, true);
                break;
            case "CornerRadious":
                ApplyStyle(ConnectorSegmentType.Orthogonal, 2, false, false, true);
                break;
            case "SourceDecorator":
                ApplyStyle(ConnectorSegmentType.Straight, 2, false, true);
                break;
            case "SourceDecoratorWithDashArray":
                ApplyStyle(ConnectorSegmentType.Straight, 2, true, true);
                break;
        }

        CssClass[SelectedConnectorType] = DefaultCssClass;
        SelectedConnectorType = typeSelected;
        CssClass[SelectedConnectorType] = SelectedCssClass;
    }

    private void UpdateConnectorStyle(Connector connector, ConnectorSegmentType type, int strokeWidth, bool isDashedLine = false, bool hasSourceDecorator = false, bool isRounded = false)
    {
        if (hasSourceDecorator)
        {
            connector.SourceDecorator = new DecoratorSettings()
            {
                Shape = DecoratorShape.Circle,
                Style = new ShapeStyle()
                {
                    StrokeColor = "#6f409f",
                    Fill = "#6f409f",
                    StrokeWidth = strokeWidth
                }
            };
        }
        else
        {
            connector.SourceDecorator!.Shape = DecoratorShape.None;
        }
        connector.Type = type;
        connector.Style!.StrokeWidth = strokeWidth;
        connector.CornerRadius = isRounded ? 5 : 0;
        connector.Style.StrokeDashArray = isDashedLine ? "5,5" : string.Empty;
        connector.TargetDecorator!.Style.StrokeWidth = strokeWidth;
    }

    private void ApplyStyle(ConnectorSegmentType type, int strokeWidth, bool isDashedLine = false, bool hasSourceDecorator = false, bool isRounded = false)
    {
        if (SelectedShapeOption == "All shapes")
        {
            DiagramInstance!.StartGroupAction();
            foreach (Connector connector in DiagramInstance.Connectors!)
            {
                this.UpdateConnectorStyle(connector, type, strokeWidth, isDashedLine, hasSourceDecorator, isRounded);
            }
            DiagramInstance.EndGroupAction();
        }
        if (SelectedShapeOption == "Selected Shapes" && DiagramInstance!.SelectionSettings!.Connectors!.Count > 0)
        {
            DiagramInstance.StartGroupAction();
            for (var i = 0; i < DiagramInstance.SelectionSettings.Connectors.Count; i++)
            {
                Connector selectedconnector = selectionSettings.Connectors![i] as Connector;
                this.UpdateConnectorStyle(selectedconnector, type, strokeWidth, isDashedLine, hasSourceDecorator, isRounded);
            }
            DiagramInstance.EndGroupAction();
        };
    }

    private void UpdateConstraintsValue(Connector connector, ButtonChangeArgs args)
    {
        if (args.Checked)
        {
            connector.Constraints = (connector.Constraints & ~(ConnectorConstraints.DragSourceEnd
                | ConnectorConstraints.DragTargetEnd | ConnectorConstraints.DragSegmentThumb | ConnectorConstraints.Drag)) | ConnectorConstraints.ReadOnly;
        }
        else
        {
            connector.Constraints = (connector.Constraints | ConnectorConstraints.Default | ConnectorConstraints.DragSegmentThumb) & ~(ConnectorConstraints.ReadOnly);
        }
    }

    public void ConstraintsChange(ButtonChangeArgs args)
    {
        IsChecked = args.Checked;
        DiagramInstance!.BeginUpdate();
        if (DiagramInstance.Connectors!.Count > 0)
        {
            if (SelectedShapeOption == "All shapes")
            {
                for (int i = 0; i < DiagramInstance.Connectors.Count; i++)
                {
                    this.UpdateConstraintsValue(DiagramInstance.Connectors[i], args);
                }
            }
            if (SelectedShapeOption == "Selected Shapes" && DiagramInstance.SelectionSettings!.Connectors!.Count > 0)
            {
                for (var i = 0; i < DiagramInstance.SelectionSettings.Connectors.Count; i++)
                {
                    Connector selectedConnector = DiagramInstance.SelectionSettings.Connectors[i] as Connector;
                    this.UpdateConstraintsValue(selectedConnector, args);
                }
            };
            _ = DiagramInstance.EndUpdateAsync();
        }
    }
    @*End:Hidden*@

    // Method to update common style for connector
    private void ConnectorCreating(IDiagramObject obj)
    {
        Connector connector = new Connector()
        {
            TargetDecorator = new DecoratorSettings()
            {
                Shape = DecoratorShape.Arrow,
                Style = new ShapeStyle() { Fill = "#6f409f", StrokeColor = "#6f409f", StrokeWidth = 2 }
            },
            Style = new ShapeStyle() { StrokeColor = "#6f409f", StrokeWidth = 2 },
            Type = ConnectorSegmentType.Bezier,
        };
    }

    // Method to create port
    private PointPort CreatePort(string id, double x, double y)
    {
        return new PointPort()
        {
            ID = id,
            Offset = new DiagramPoint() { X = x, Y = y },
            Visibility = PortVisibility.Hidden
        };
    }

    // Method to create node
    private void CreateNode(string id, double x, double y, string label, object? ports = null)
    {
        Node diagramNode = new Node()
        {
            ID = id,
            OffsetX = x,
            OffsetY = y,
            Width = 80,
            Height = 35,
            Annotations = new DiagramObjectCollection<ShapeAnnotation>() { new ShapeAnnotation() { Content = label } },
        };
        if (ports != null)
        {
            diagramNode.Ports = ports as DiagramObjectCollection<PointPort>;
        }
        DiagramNodes!.Add(diagramNode);
    }

    // Method to create connector
    private void CreateConnector(string sourceId, string targetId, string? sourcePort, string? targetPort)
    {
        Connector diagramConnector = new Connector()
        {
            ID = string.Format("connector{0}", ++DiagramConnectorCount),
            SourceID = sourceId,
            Style = new ShapeStyle() { StrokeColor = "#6f409f", StrokeWidth = 2 },
            TargetID = targetId,
            SourcePortID = sourcePort,
            TargetPortID = targetPort,
            SourceDecorator = new DecoratorSettings()
            {
                Shape = DecoratorShape.None,
                Style = new ShapeStyle() { Fill = "#6f409f", StrokeColor = "#6f409f", StrokeWidth = 2 }
            },
            TargetDecorator = new DecoratorSettings()
            {
                Shape = DecoratorShape.Arrow,
                Style = new ShapeStyle() { Fill = "#6f409f", StrokeColor = "#6f409f", StrokeWidth = 2 }
            },
            Type = ConnectorSegmentType.Bezier,
            Constraints = ConnectorConstraints.Default | ConnectorConstraints.DragSegmentThumb
        };
        diagramConnector.BezierConnectorSettings.AllowSegmentsReset = false;
        DiagramConnectors!.Add(diagramConnector);
    }

    private void OnSegmentShapeChange(ChangeEventArgs<string, DiagramShapeModel> args)
    {
        DiagramInstance!.BeginUpdate();
        if (SelectedShapeOption == "All shapes")
        {
            for (int i = 0; i < DiagramInstance.Connectors!.Count; i++)
            {
                this.UpdateSegmentShape(DiagramInstance.Connectors[i], args.Value!.ToString());
            }
        }
        if (SelectedShapeOption == "Selected Shapes" && DiagramInstance.SelectionSettings!.Connectors!.Count > 0)
        {
            DiagramInstance.StartGroupAction();
            for (var i = 0; i < DiagramInstance.SelectionSettings.Connectors.Count; i++)
            {
                Connector selectedconnector = selectionSettings.Connectors![i] as Connector;
                this.UpdateSegmentShape(selectedconnector, args.Value!.ToString());
            }
            DiagramInstance.EndGroupAction();
        }
        _ = DiagramInstance.EndUpdateAsync();
    }

    private void UpdateSegmentShape(Connector connector, string shape)
    {
        connector.SegmentThumbSettings.Shape = Enum.Parse<SegmentThumbShapes>(shape, true);
    }

    @*Hidden:Lines*@
    public void Dispose()
    {
        if (DiagramNodes != null)
        {
            DiagramNodes.Clear();
            DiagramNodes = null;
        }
        if (DiagramConnectors != null)
        {
            DiagramConnectors.Clear();
            DiagramConnectors = null;
        }
    }
    @*End:Hidden*@
}