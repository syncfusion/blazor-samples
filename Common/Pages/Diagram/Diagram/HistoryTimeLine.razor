@page "/diagram/history-timeline"

@using Syncfusion.Blazor.Diagram
@using Syncfusion.Blazor.Inputs
@using Syncfusion.Blazor.Buttons
@using Syncfusion.Blazor.Popups
@*Hidden:Lines*@
@inherits SampleBaseComponent
@implements IDisposable
@inject NavigationManager NavigationManager

<SampleDescription>
    <p>
        This sample visualizes key milestones in Internet history using the interactive Syncfusion<sup>Â®</sup> Blazor Diagram component. Events are presented as nodes on a horizontal timeline, with color-coded sections and customizable event details.
    </p>
</SampleDescription>
<ActionDescription>
    <p>
        This interactive timeline displays Internet history events as styled nodes along a central bar, alternating above and below for visual variety. Color-coded segments define historical periods, and tooltip provide event descriptions on hover. Users can dynamically add or edit events, ensuring chronological accuracy with real-time updates.
    </p>
</ActionDescription>
@*End:Hidden*@

<div id="timeline-container">
    <div id="timeline-header">
        <h1>Internet History Timeline</h1>
        <p>A comprehensive timeline of key events in Internet development from 1969 to 2035</p>
    </div>
    <div class="control-section">
        <div class="content-wrapper" style="width: 100%">
            <SfDiagramComponent @ref="DiagramRef"
                                ID="Diagram"
                                Height="600px"
                                Width="100%"
                                Nodes="@Nodes"
                                Connectors="@Connectors"
                                Constraints="@DiagramConstraints"
                                NodeCreating="@OnNodeCreating"
                                InteractionController="@Tools"
                                ConnectorCreating="@OnConnectorCreating"
                                SelectionSettings="@SelectionSettings"
                                SelectionChanged="@OnSelectionChanged"
                                Created="@OnDiagramCreated"
                                GetCustomTool="GetCustomTool"
                                Click="OnClicked"
                                PositionChanging="OnPositionChanging">
                <SnapSettings Constraints="SnapConstraints.None"></SnapSettings>
                <PageSettings MultiplePage="true" Width="500" Height="300"></PageSettings>
                <DiagramTemplates>
                    <NodeTemplate>
                        @{
                            if (context is Node node)
                            {
                                if (node.ID!.Contains("timeline_line"))
                                {
                                    <div class="timeline-line">
                                        @for (int i = 0; i < TimelineEvents.Count; i++)
                                        {
                                            var colorIndex = i % EventColors.Length;
                                            var segmentColor = EventColors[colorIndex];
                                            <div class="timeline-segment" style="background-color: @segmentColor;"></div>
                                        }
                                    </div>
                                }
                                else if (node.ID.StartsWith("timeline_"))
                                {
                                    var eventIndex = GetEventIndexFromNode(node);
                                    if (eventIndex >= 0 && eventIndex < TimelineEvents.Count)
                                    {
                                        var eventItem = TimelineEvents[eventIndex];
                                        var colorIndex = eventIndex % EventColors.Length;
                                        var nodeColor = EventColors[colorIndex];
                                        @if (!string.IsNullOrEmpty(eventItem.ImageUrl))
                                        {
                                            <div class="timeline-event-node" style="background-color: @nodeColor;">
                                                <div class="timeline-event-icon">
                                                    <img src="@eventItem.ImageUrl" alt="Event Image" style="max-width: 100%; max-height: 60px; border-radius: 3px;" />
                                                </div>
                                                <div class="timeline-event-title"><strong>@eventItem.Title</strong></div>
                                            </div>
                                        }
                                        else
                                        {
                                            <div class="timeline-event-node" style="background-color: @nodeColor;">
                                                <div class="timeline-event-icon @eventItem.Icon"></div>
                                                <div class="timeline-event-title"><strong>@eventItem.Title</strong></div>
                                            </div>
                                        }
                                    }
                                }
                                else if (node.ID.StartsWith("marker_"))
                                {
                                    var eventIndex = GetEventIndexFromNode(node);
                                    if (eventIndex >= 0 && eventIndex < TimelineEvents.Count)
                                    {
                                        var eventItem = TimelineEvents[eventIndex];
                                        <div class="timeline-year-marker">
                                            <div class="timeline-year-circle">
                                                @eventItem.Year
                                            </div>
                                        </div>
                                    }
                                }
                            }
                        }
                    </NodeTemplate>
                    <TooltipTemplate>
                        @{
                            if (context is Node node && node.AdditionalInfo != null)
                            {
                                <div style="color: black; padding: 8px 12px; border-radius: 6px; font-family: 'Segoe UI', sans-serif; max-width: 300px;">
                                    <div style="font-weight: bold; font-size: 13px; margin-bottom: 4px; color: black;">
                                        ðŸ“… @node.AdditionalInfo["Year"]: @node.AdditionalInfo["Title"]
                                    </div>
                                    <hr />
                                    <div style="font-size: 12px; color: black;">
                                        @node.AdditionalInfo["Description"]
                                    </div>
                                </div>
                            }
                        }
                    </TooltipTemplate>
                </DiagramTemplates>
            </SfDiagramComponent>
        </div>
    </div>
    <SfDialog @ref="DialogRef"
              @bind-Visible="DialogVisible"
              Target="#timeline-container"
              Width="300px"
              IsModal="true"
              Header="@DialogHeader">
        <DialogTemplates>
            <Content>
                <div style="padding: 0px 15px 15px 15px;">
                    <form id="form-element" class="form-horizontal e-formvalidator" novalidate>
                        <div class="form-group">
                            <label for="yearInput">Year:</label>
                            <SfTextBox @ref="YearTextBoxRef"
                                       @bind-Value="CurrentEvent.Year"
                                       ID="yearInput"
                                       Name="yearInput"
                                       Placeholder="e.g., 2025"
                                       FloatLabelType="FloatLabelType.Never"
                                       CssClass="@(ShowValidationErrors && string.IsNullOrWhiteSpace(CurrentEvent.Year) ? "e-outline e-error" : "e-outline")"
                                       Required="true" />
                            @if (ShowValidationErrors && string.IsNullOrWhiteSpace(CurrentEvent.Year))
                            {
                                <label class="e-error" for="yearInput" id="yearInput-info">This field is required.</label>
                            }
                            @if (ShowValidationErrors && !string.IsNullOrWhiteSpace(CurrentEvent.Year) && !ValidateYear(CurrentEvent.Year))
                            {
                                <label class="e-error" for="yearInput" id="yearInput-range-info">Year must be within valid range compared to adjacent events.</label>
                            }
                        </div>
                        <div class="form-group">
                            <label for="titleInput">Title:</label>
                            <SfTextBox @ref="TitleTextBoxRef"
                                       @bind-Value="CurrentEvent.Title"
                                       ID="titleInput"
                                       Name="titleInput"
                                       Placeholder="Event Title"
                                       FloatLabelType="FloatLabelType.Never"
                                       CssClass="@(ShowValidationErrors && string.IsNullOrWhiteSpace(CurrentEvent.Title) ? "e-outline e-error" : "e-outline")"
                                       Required="true" />
                            @if (ShowValidationErrors && string.IsNullOrWhiteSpace(CurrentEvent.Title))
                            {
                                <label class="e-error" for="titleInput" id="titleInput-info">This field is required.</label>
                            }
                        </div>
                        <div class="form-group">
                            <label for="descriptionInput">Description:</label>
                            <SfTextArea @ref="DescriptionTextBoxRef"
                                        @bind-Value="CurrentEvent.Description"
                                        ID="descriptionInput"
                                        Name="descriptionInput"
                                        Width="100%"
                                        RowCount="2"
                                        Placeholder="Brief description of the event"
                                        CssClass="@(ShowValidationErrors && string.IsNullOrWhiteSpace(CurrentEvent.Description) ? "e-outline e-error" : "e-outline")"
                                        FloatLabelType="FloatLabelType.Never" />
                            @if (ShowValidationErrors && string.IsNullOrWhiteSpace(CurrentEvent.Description))
                            {
                                <label class="e-error" for="descriptionInput" id="descriptionInput-info">This field is required.</label>
                            }
                        </div>
                        <div class="form-group">
                            <label for="imageUrlInput">Image Url:</label>
                            <SfTextBox @ref="ImageUrlTextBoxRef"
                                       @bind-Value="CurrentEvent.ImageUrl"
                                       ID="imageUrlInput"
                                       Name="imageUrlInput"
                                       Placeholder="https://example.com/image.jpg"
                                       FloatLabelType="FloatLabelType.Never"
                                       CssClass="e-outline" />
                        </div>
                    </form>
                </div>
            </Content>
        </DialogTemplates>
        <DialogButtons>
            <DialogButton Content="Submit" IsPrimary="true" OnClick="@OnSubmitClicked" />
            <DialogButton Content="Cancel" OnClick="@OnCancelClicked" />
        </DialogButtons>
    </SfDialog>
</div>

@code {

    #region Diagram
    public SfDiagramComponent? DiagramRef;

    // Defines Diagram's nodes collection.
    public DiagramObjectCollection<Node>? Nodes = new DiagramObjectCollection<Node>();
    // Defines Diagram's connectors collection.
    public DiagramObjectCollection<Connector>? Connectors = new DiagramObjectCollection<Connector>();
    public DiagramInteractions Tools = DiagramInteractions.ZoomPan | DiagramInteractions.SingleSelect;
    public DiagramConstraints DiagramConstraints = (DiagramConstraints.Default & ~DiagramConstraints.PanY) | DiagramConstraints.UndoRedo;
    public DiagramObjectCollection<UserHandle> UserHandles { get; set; } = new DiagramObjectCollection<UserHandle>();
    public DiagramSelectionSettings? SelectionSettings { get; set; }

    #endregion

    #region Dialog
    public SfDialog? DialogRef;
    public SfTextBox? YearTextBoxRef;
    public SfTextBox? TitleTextBoxRef;
    public SfTextArea? DescriptionTextBoxRef;
    public SfTextBox? ImageUrlTextBoxRef;

    public bool DialogVisible = false;
    public string DialogHeader = "";
    public string SelectedUserHandle = "";
    public bool ShowValidationErrors { get; set; } = false;

    #endregion
    public Node? SelectedNode;

    public int EditTimeLineIndex = -1;

    public List<string> IndexTable = new List<string>();
    public List<TimelineEvent> TimelineEvents = new List<TimelineEvent>();
    public TimelineEvent CurrentEvent = new TimelineEvent();

    protected override void OnInitialized()
    {
        InitializeTimelineData();
        CreateTimelineNodes();
        CreateTimelineConnectors();
        InitializeUserHandles();
    }
    public const double StartX = 100;
    public const double StartY = 100;
    public const double NodeSpacing = 200;
    public const double AlternateOffset = 200;
    public const double BaseLine = 300;
    public class TimelineEvent
    {
        public string Year { get; set; } = "";
        public string Title { get; set; } = "";
        public string Description { get; set; } = "";
        public string Icon { get; set; } = "";
        public string ImageUrl { get; set; } = "";
    }
    public readonly string[] EventColors = {
        "#FEC200", "#43C94C", "#3D95F6", "#FF3343", "#CDDE1F",
        "#00897B", "#7F38CD", "#FF2667", "#00BCD7", "#F47B10",
        "#576ADE", "#91521B"
    };
    public void InitializeTimelineData()
    {
        TimelineEvents = new List<TimelineEvent>
        {
            new TimelineEvent { Year = "1969", Title = "ARPANET", Description = "ARPANET, the precursor to the Internet, is created by the U.S. Department of Defense's Advanced Research Projects Agency (ARPA).", Icon = "sf-icon-arpanet" },
            new TimelineEvent { Year = "1983", Title = "Birth of the Internet", Description = "ARPANET switches to TCP/IP, marking the official birth of the Internet.", Icon = "sf-icon-birth-internet" },
            new TimelineEvent { Year = "1991", Title = "Internet Goes Public", Description = "The World Wide Web is released to the public, making the Internet accessible to a broader audience.", Icon = "sf-icon-internet-public" },
            new TimelineEvent { Year = "1993", Title = "First Web Browser", Description = "The first web browser, Mosaic, is released, making it easier for people to access the World Wide Web.", Icon = "sf-icon-first-web-browser" },
            new TimelineEvent { Year = "1995", Title = "Commercialization of the Internet", Description = "The U.S. government lifts restrictions on commercial use of the Internet, leading to the rise of commercial websites and e-commerce.", Icon = "sf-icon-commercialization" },
            new TimelineEvent { Year = "1998", Title = "Google Founded", Description = "Google is founded by Larry Page and Sergey Brin, revolutionizing how people search for information online.", Icon = "sf-icon-google-found" },
            new TimelineEvent { Year = "2004", Title = "Social Media Boom", Description = "Facebook is launched, marking the beginning of the social media era.", Icon = "sf-icon-social-media" },
            new TimelineEvent { Year = "2005", Title = "YouTube Launched", Description = "YouTube is launched, becoming a major platform for sharing and viewing video content.", Icon = "sf-icon-youtube" },
            new TimelineEvent { Year = "2007", Title = "iPhone Released", Description = "Apple releases the first iPhone, transforming mobile internet usage and leading to the proliferation of mobile apps.", Icon = "sf-icon-i-phone" },
            new TimelineEvent { Year = "2010", Title = "Cloud Computing", Description = "Cloud computing becomes mainstream, allowing for more flexible and scalable internet services.", Icon = "sf-icon-cloud-computing" },
            new TimelineEvent { Year = "2014", Title = "Internet of Things (IoT)", Description = "The Internet of Things (IoT) gains significant traction, connecting everyday devices to the internet.", Icon = "sf-icon-internet-of-things" },
            new TimelineEvent { Year = "2020", Title = "Remote Work", Description = "The COVID-19 pandemic accelerates the adoption of remote work, online education, and digital communication.", Icon = "sf-icon-remote-work" },
            new TimelineEvent { Year = "2021", Title = "5G Rollout", Description = "The global rollout of 5G networks begins, promising significantly faster internet speeds and lower latency.", Icon = "sf-icon-5g-network" },
            new TimelineEvent { Year = "2022", Title = "Metaverse Development", Description = "Major technology companies begin to invest heavily in the development of the metaverse, virtual and augmented reality spaces.", Icon = "sf-icon-metaverse" },
            new TimelineEvent { Year = "2023", Title = "Quantum Internet", Description = "Continued research and development in quantum computing and quantum internet technology aim to revolutionize data security and processing speeds.", Icon = "sf-icon-quantum-internet" },
            new TimelineEvent { Year = "2025", Title = "IoT Pervasiveness", Description = "The Internet of Things becomes more pervasive, with smart devices deeply integrated into daily life and industry.", Icon = "sf-icon-iot-pervasiveness" },
            new TimelineEvent { Year = "2030", Title = "Autonomous Vehicles", Description = "The widespread adoption of autonomous vehicles becomes more common, relying heavily on the internet for communication, navigation, and updates.", Icon = "sf-icon-autonomous-vehicle" },
            new TimelineEvent { Year = "2035", Title = "Advanced AI Integration", Description = "Advanced AI systems are fully integrated into internet services, offering more personalized and efficient user experiences.", Icon = "sf-icon-advance-ai" }
        };

        // Initialize index table
        IndexTable.Clear();
        for (int i = 0; i < TimelineEvents.Count; i++)
        {
            IndexTable.Add(i.ToString());
        }
    }
    public void CreateTimelineNodes()
    {
        // Create main timeline line
        var timelineLine = new Node()
        {
            ID = "timeline_line",
            OffsetX = (TimelineEvents.Count * NodeSpacing) / 2,
            OffsetY = BaseLine,
            Width = TimelineEvents.Count * NodeSpacing,
            Height = 10,
            Constraints = NodeConstraints.Default & ~NodeConstraints.Select,
            Shape = new BasicShape()
            {
                Type = NodeShapes.HTML,
            }
        };
        Nodes!.Add(timelineLine);

        // Create timeline event nodes
        for (int index = 0; index < TimelineEvents.Count; index++)
        {
            var eventItem = TimelineEvents[index];
            var colorIndex = index % EventColors.Length;
            var nodeColor = EventColors[colorIndex];
            var isOdd = (index + 1) % 2 != 0;
            var x = StartX + (index * NodeSpacing);
            var y = isOdd ? StartY : BaseLine + AlternateOffset;

            // Timeline Event Node
            var timelineNode = new Node()
            {
                ID = $"timeline_{index}",
                OffsetX = x,
                OffsetY = y,
                Width = 130,
                Height = 100,
                Constraints = (NodeConstraints.Default & ~NodeConstraints.Select) | NodeConstraints.Tooltip | NodeConstraints.ReadOnly,
                Style = new ShapeStyle { Fill = "none" },
                Shape = new BasicShape()
                {
                    Type = NodeShapes.HTML,
                },
                Tooltip = new DiagramTooltip
                {
                    Content = $"{eventItem.Year}: {eventItem.Description}",
                    Position = isOdd ? Position.TopCenter : Position.BottomCenter,
                    AnimationSettings = new AnimationModel()
                    {
                        Open = new TooltipAnimationSettings() { Effect = Effect.FadeZoomIn, Duration = 200 },
                        Close = new TooltipAnimationSettings() { Effect = Effect.FadeZoomOut, Duration = 150 }
                    }
                },
                AdditionalInfo = new Dictionary<string, object>
            {
                    {"Year", eventItem.Year},
                    {"Title", eventItem.Title},
                    {"Description", eventItem.Description},
                    {"EventIndex", index}
                }
            };

            // Timeline Year Marker Node
            var yearMarker = new Node()
            {
                ID = $"marker_{index}",
                OffsetX = x,
                OffsetY = BaseLine,
                Width = 170,
                Height = 50,
                Constraints = (NodeConstraints.Default) | NodeConstraints.ReadOnly,
                Shape = new BasicShape()
                {
                    Type = NodeShapes.HTML,
                },
                AdditionalInfo = new Dictionary<string, object>
            {
                    {"EventIndex", index}
                }
            };

            Nodes.Add(timelineNode);
            Nodes.Add(yearMarker);
        }
    }
    public void CreateTimelineConnectors()
    {
        for (int index = 0; index < TimelineEvents.Count; index++)
        {
            var colorIndex = index % EventColors.Length;
            var strokeColor = EventColors[colorIndex];
            var connector = new Connector()
            {
                ID = $"connector_{index}",
                SourceID = $"timeline_{index}",
                TargetID = $"marker_{index}",
                Style = new ShapeStyle
                {
                    StrokeColor = strokeColor,
                    StrokeWidth = 2
                },
            };
            Connectors!.Add(connector);
        }
    }
    public void InitializeUserHandles()
    {
        UserHandles = new DiagramObjectCollection<UserHandle>
    {
             new UserHandle
             {
                 ID = "NewEvent",
                 Name = "NewEvent",
                 PathData = "M256 80c0-17.7-14.3-32-32-32s-32 14.3-32 32V224H48c-17.7 0-32 14.3-32 32s14.3 32 32 32H192V432c0 17.7 14.3 32 32 32s32-14.3 32-32V288H400c17.7 0 32-14.3 32-32s-14.3-32-32-32H256V80z",
                 Offset = 0.5,
                 Side = Direction.Right,
                 Visible = true,
                 Margin = new DiagramThickness { Right = 10 },
                 Tooltip = new DiagramTooltip { Content = "Add Event",}
             },
             new UserHandle
             {
                 ID = "EditEvent",
                 Name = "EditEvent",
                 PathData = "M410.3 231l11.3-11.3-33.9-33.9-62.1-62.1L291.7 89.8l-11.3 11.3-22.6 22.6L58.6 322.9c-10.4 10.4-18 23.3-22.2 37.4L1 480.7c-2.5 8.4-.2 17.5 6.1 23.7s15.3 8.5 23.7 6.1l120.3-35.4c14.1-4.2 27-11.8 37.4-22.2L387.7 253.7 410.3 231zM160 399.4l-9.1 22.7c-4 3.1-8.5 5.4-13.3 6.9L59.4 452l23-78.1c1.4-4.9 3.8-9.4 6.9-13.3l22.7-9.1v32c0 8.8 7.2 16 16 16h32zM362.7 18.7L348.3 33.2 325.7 55.8 314.3 67.1l33.9 33.9 62.1 62.1 33.9 33.9 11.3-11.3 22.6-22.6 14.5-14.5c25-25 25-65.5 0-90.5L453.3 18.7c-25-25-65.5-25-90.5 0zm-47.4 168l-144 144c-6.2 6.2-16.4 6.2-22.6 0s-6.2-16.4 0-22.6l144-144c6.2-6.2 16.4-6.2 22.6 0s6.2 16.4 0 22.6z",
                 Offset = 0.5,
                 Side = Direction.Bottom,
                 Visible = true,
                 Margin = new DiagramThickness { Bottom = 10 },
                 Tooltip = new DiagramTooltip { Content = "Edit Event",}
             }
        };

        SelectionSettings = new DiagramSelectionSettings()
        {
            Constraints = SelectorConstraints.UserHandle,
            UserHandles = this.UserHandles
        };
    }
    public void OnDiagramCreated()
    {
        DiagramRef!.FitToPage(new FitOptions() { Mode = FitMode.Height, Region = DiagramRegion.PageSettings });
    }

    // Helper methods for template rendering
    public Dictionary<string, object>? GetTimelineNodeData(Node node)
    {
        var eventIndex = GetEventIndexFromNode(node);
        if (eventIndex >= 0 && eventIndex < TimelineEvents.Count)
        {
            var eventItem = TimelineEvents[eventIndex];
            return new Dictionary<string, object>
        {
                {"EventIndex", eventIndex},
                {"Year", eventItem.Year},
                {"Title", eventItem.Title},
                {"Description", eventItem.Description},
                {"Icon", eventItem.Icon}
            };
        }
        return null;
    }

    // Modified method to accept Node parameter instead of nodeId
    public int GetEventIndexFromNode(Node node)
    {
        if (node == null)
            return -1;

        // If parsing failed, check if node has Year in AdditionalInfo
        if (node.AdditionalInfo != null && node.AdditionalInfo.ContainsKey("Year"))
        {
            string? year = node.AdditionalInfo["Year"]?.ToString();
            if (!string.IsNullOrEmpty(year))
            {
                // Find the index of the timeline event with matching year
                return TimelineEvents.FindIndex(e => e.Year == year);
            }
        }

        // If we have EventIndex directly in AdditionalInfo, use that
        if (node.AdditionalInfo != null && node.AdditionalInfo.ContainsKey("EventIndex"))
        {
            if (node.AdditionalInfo["EventIndex"] is int eventIndex)
            {
                return eventIndex;
            }
        }

        return -1;
    }

    public void OnNodeCreating(IDiagramObject obj)
    {
        if (obj is Node node)
        {
            node.Shape = new BasicShape()
            {
                Type = NodeShapes.HTML,
            };
        }
    }

    public void OnConnectorCreating(IDiagramObject obj)
    {
        if (obj is Connector connector)
        {
            // Enable tooltip for all connectors
            connector.Constraints = ConnectorConstraints.Default & ~(ConnectorConstraints.Select | ConnectorConstraints.Drag);
            connector.Type = ConnectorSegmentType.Straight;
            connector.TargetDecorator = new DecoratorSettings { Shape = DecoratorShape.None };
            connector.SourceDecorator = new DecoratorSettings { Shape = DecoratorShape.None };

        }
    }

    public void OnSelectionChanged(Syncfusion.Blazor.Diagram.SelectionChangedEventArgs args)
    {
        if (args.NewValue!.Count > 0 && DiagramRef!.SelectionSettings!.Nodes!.Count > 0)
        {
            SelectedNode = DiagramRef.SelectionSettings!.Nodes[0];
            if (SelectedNode.AdditionalInfo != null && SelectedNode.AdditionalInfo.ContainsKey("EventIndex"))
            {
                EditTimeLineIndex = (int)SelectedNode.AdditionalInfo["EventIndex"];
                bool isImmediateNext = IsImmediateNextYear(EditTimeLineIndex);

                if (UserHandles.Count >= 2)
                {
                    UserHandles[0].Visible = !isImmediateNext;
                    UserHandles[1].Visible = true;
                }
            }
            else
            {
                if (UserHandles.Count >= 2)
                {
                    UserHandles[0].Visible = false;
                    UserHandles[1].Visible = false;
                }
            }
        }
        else
        {
            if (DiagramRef!.SelectionSettings?.Nodes?.Count > 0)
            {
                DiagramRef.ClearSelection();
            }
        }
    }

    public bool IsImmediateNextYear(int currentIndex)
    {
        var nextYearIndex = currentIndex + 1;
        if (nextYearIndex < TimelineEvents.Count &&
            int.TryParse(TimelineEvents[nextYearIndex].Year, out int nextYear) &&
            int.TryParse(TimelineEvents[currentIndex].Year, out int currentYear))
        {
            return (nextYear - currentYear) == 1;
        }
        return false;
    }

    // Custom tool implementation for user handle clicks
    public InteractionControllerBase GetCustomTool(DiagramElementAction action, string id)
    {
        if (id == "NewEvent")
        {
            DialogHeader = SelectedUserHandle = "New Event";
            CurrentEvent = new TimelineEvent();
            DialogVisible = true;
            StateHasChanged();
        }
        else if (id == "EditEvent")
        {
            DialogHeader = SelectedUserHandle = "Edit Event";
            if (EditTimeLineIndex >= 0)
            {
                var timeLine = TimelineEvents[EditTimeLineIndex];
                CurrentEvent = new TimelineEvent
                {
                    Year = timeLine.Year,
                    Title = timeLine.Title,
                    Description = timeLine.Description,
                    Icon = timeLine.Icon
                };
            }
            DialogVisible = true;
            StateHasChanged();
        }
        return null!;
    }
    public bool ValidateYear(string year)
    {
        if (!int.TryParse(year, out int currentYear))
            return false;

        int previousYearIndex = SelectedUserHandle == "Edit Event" ? EditTimeLineIndex - 1 : EditTimeLineIndex;

        // Validate against previous event
        if (previousYearIndex >= 0)
        {
            if (!int.TryParse(TimelineEvents[previousYearIndex].Year, out int prevYear))
                return false;
            if (prevYear >= currentYear)
                return false;
        }

        // Validate against next event
        int nextYearIndex = SelectedUserHandle == "Edit Event" ? EditTimeLineIndex + 1 : EditTimeLineIndex + 1;
        if (nextYearIndex < TimelineEvents.Count)
        {
            if (!int.TryParse(TimelineEvents[nextYearIndex].Year, out int nextYear))
                return false;
            if (nextYear <= currentYear)
                return false;
        }

        return true;
    }

    public async Task OnSubmitClicked()
    {
        // Check for validation and show errors if needed
        if (string.IsNullOrWhiteSpace(CurrentEvent.Year) ||
            string.IsNullOrWhiteSpace(CurrentEvent.Title) ||
            string.IsNullOrWhiteSpace(CurrentEvent.Description) ||
            !ValidateYear(CurrentEvent.Year))
        {
            ShowValidationErrors = true;
            StateHasChanged();
            return;
        }

        // Reset validation state
        ShowValidationErrors = false;

        if (SelectedUserHandle == "New Event")
        {
            var insertIndex = EditTimeLineIndex + 1;
            CurrentEvent.Icon = "sf-icon-internet-public";
            TimelineEvents.Insert(insertIndex, CurrentEvent);

            // Add new node
            await AddNewTimelineEvent(insertIndex, CurrentEvent);

            // Update positions for nodes after the insertion point
            UpdateNodePositions(insertIndex + 1);
        }
        else if (SelectedUserHandle == "Edit Event" && EditTimeLineIndex >= 0)
        {
            CurrentEvent.Icon = TimelineEvents[EditTimeLineIndex].Icon;
            TimelineEvents[EditTimeLineIndex] = CurrentEvent;

            // Update the existing node
            await EditTimelineNode(EditTimeLineIndex, CurrentEvent);
        }

        bool isImmediateNext = IsImmediateNextYear(EditTimeLineIndex);

        if (UserHandles.Count >= 2)
        {
            UserHandles[0].Visible = !isImmediateNext;
            UserHandles[1].Visible = true;
        }

        DialogVisible = false;
        StateHasChanged();
    }
    public async Task AddNewTimelineEvent(int insertIndex, TimelineEvent newEvent)
    {
        var colorIndex = insertIndex % EventColors.Length;
        var nodeColor = EventColors[colorIndex];
        var isOdd = (insertIndex + 1) % 2 != 0;
        var x = StartX + (insertIndex * NodeSpacing);
        var y = isOdd ? StartY : BaseLine + AlternateOffset;
        var id = Guid.NewGuid().ToString("N")[..8];

        // Create new timeline node
        var timelineNode = new Node()
        {
            ID = $"timeline_{id}",
            OffsetX = x,
            OffsetY = y,
            Width = 130,
            Height = 100,
            Constraints = (NodeConstraints.Default & ~(NodeConstraints.Select)) | NodeConstraints.Tooltip | NodeConstraints.ReadOnly,
            Style = new ShapeStyle { Fill = "none" },
            Shape = new BasicShape()
            {
                Type = NodeShapes.HTML,
            },
            Tooltip = new DiagramTooltip
            {
                Content = $"{newEvent.Year}: {newEvent.Description}",
                Position = isOdd ? Position.TopCenter : Position.BottomCenter,
                AnimationSettings = new AnimationModel()
                {
                    Open = new TooltipAnimationSettings() { Effect = Effect.FadeZoomIn, Duration = 200 },
                    Close = new TooltipAnimationSettings() { Effect = Effect.FadeZoomOut, Duration = 150 }
                }
            },
            AdditionalInfo = new Dictionary<string, object>
{
              {"Year", newEvent.Year},
              {"Title", newEvent.Title},
              {"Description", newEvent.Description},
              {"EventIndex", insertIndex}
            }
        };

        // Create new year marker node
        var yearMarker = new Node()
        {
            ID = $"marker_{id}",
            OffsetX = x,
            OffsetY = BaseLine,
            Width = 170,
            Height = 50,
            Constraints = (NodeConstraints.Default) | NodeConstraints.ReadOnly,
            Shape = new BasicShape()
            {
                Type = NodeShapes.HTML,
            },
            AdditionalInfo = new Dictionary<string, object>
{
              {"EventIndex", insertIndex}
            }
        };

        // Create new connector
        var connector = new Connector()
        {
            ID = $"connector_{id}",
            SourceID = $"timeline_{id}",
            TargetID = $"marker_{id}",
            Constraints = ConnectorConstraints.None,
            Style = new ShapeStyle
            {
                StrokeColor = nodeColor,
                StrokeWidth = 2
            },
            Type = ConnectorSegmentType.Straight,
            TargetDecorator = new DecoratorSettings { Shape = DecoratorShape.None },
            SourceDecorator = new DecoratorSettings { Shape = DecoratorShape.None }
        };

        // Push node to index table to maintain event order
        IndexTable.Insert(insertIndex, id);

        // Add new nodes and connector to diagram
        await DiagramRef!.AddDiagramElementsAsync(new DiagramObjectCollection<NodeBase>() { timelineNode, yearMarker, connector });

    }

    public void UpdateNodePositions(int fromIndex)
    {
        for (int i = fromIndex; i < TimelineEvents.Count; i++)
        {
            bool isOdd = (i + 1) % 2 != 0;
            double x = StartX + (i * NodeSpacing);
            double y = isOdd ? StartY : BaseLine + AlternateOffset;

            // Update timeline node position
            Node timelineNode = (Nodes!.FirstOrDefault(n => n.ID == $"timeline_{IndexTable[i]}") as Node)!;
            if (timelineNode != null)
            {
                timelineNode.OffsetX = x;
                timelineNode.OffsetY = y;
                timelineNode.Tooltip!.Position = isOdd ? Position.TopCenter : Position.BottomCenter;

                // Update node appearance to match colors
                int colorIndex = i % EventColors.Length;
                string nodeColor = EventColors[colorIndex];

            }

            // Update marker node position
            Node markerNode = (Nodes!.FirstOrDefault(n => n.ID == $"marker_{IndexTable[i]}") as Node)!;
            if (markerNode != null)
            {
                markerNode.OffsetX = x;
                if (markerNode.AdditionalInfo != null)
                    markerNode.AdditionalInfo["EventIndex"] = i;
            }

            // Update connector
            Connector? connector = Connectors!.FirstOrDefault(c => c.ID == $"connector_{IndexTable[i]}") as Connector;
            if (connector != null)
            {
                int colorIndex = i % EventColors.Length;
                string strokeColor = EventColors[colorIndex];
                connector.Style!.StrokeColor = strokeColor;
            }
        }

        // Update timeline line width
        Node? timelineLine = Nodes!.FirstOrDefault(n => n.ID == "timeline_line") as Node;
        if (timelineLine != null)
        {
            timelineLine.OffsetX = (TimelineEvents.Count * NodeSpacing) / 2;
            timelineLine.Width = TimelineEvents.Count * NodeSpacing;
        }
    }

    public async Task EditTimelineNode(int editIndex, TimelineEvent timeLine)
    {
        // Update the timeline node
        DiagramRef!.BeginUpdate();

        var timelineNode = Nodes!.FirstOrDefault(n => n.ID == $"timeline_{IndexTable[editIndex]}") as Node;
        if (timelineNode != null)
        {
            // Update tooltip and additional info
            timelineNode.Tooltip!.Content = $"{timeLine.Year}: {timeLine.Description}";
            if (timelineNode.AdditionalInfo != null)
            {
                timelineNode.AdditionalInfo["Year"] = timeLine.Year;
                timelineNode.AdditionalInfo["Title"] = timeLine.Title;
                timelineNode.AdditionalInfo["Description"] = timeLine.Description;
            }
        }

        // Update the year marker
        Node? markerNode = Nodes!.FirstOrDefault(n => n.ID == $"marker_{IndexTable[editIndex]}") as Node;

        await DiagramRef.EndUpdateAsync();
    }
    public void OnCancelClicked()
    {
        ShowValidationErrors = false;
        DialogVisible = false;
        StateHasChanged();
    }
    // Event to notify the position changing event while dragging the elements in diagram.
    public void OnPositionChanging(PositionChangingEventArgs args)
    {
        // Sets true to cancel the action.
        args.Cancel = true;
    }

    public void OnClicked(ClickEventArgs args)
    {
        if (args.ActualObject == null)
        {
            DiagramRef!.ClearSelection();
        }
    }
    @*Hidden:Lines*@
    public void Dispose()
    {
        if (Nodes != null)
        {
            Nodes.Clear();
            Nodes = null;
        }
        if (Connectors != null)
        {
            Connectors.Clear();
            Connectors = null;
        }
    }
    @*End:Hidden*@
}