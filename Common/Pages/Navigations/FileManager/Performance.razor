@page "/file-manager/flatdata-performance"

@using Syncfusion.Blazor.FileManager
@using Syncfusion.Blazor.DropDowns
@using Syncfusion.Blazor.Spinner
@using System.Diagnostics
@using BlazorDemos.Pages.FileManager
@using BlazorDemos.Pages.Navigations.FileManager
@using System.Globalization
@inherits SampleBaseComponent

<ActionDescription>
<p>This sample benchmarks the Blazor File Manager performance against large flat-data folder hierarchies generated in-memory.</p>
    
    <p>Performance measurement features:</p>
    
    <ul>
        <li>Select a folder count to rebuild the hierarchy</li>
        <li>Measure initial load times for performance analysis</li>
        <li>File Manager uses flat data (no backend controller)</li>
        <li>Stopwatch records the first completed <code>read</code> request after each rebuild for realistic load-time measurement</li>
    </ul>
</ActionDescription>


<div class="control-section">
    <div class="content-wrapper">
        <div class="row">
            <div class="e-dddata">
                <div class="dropdown-wrapper">
                    <SfDropDownList TItem="DDData" TValue="string" PopupHeight="230px" Width="240px"
                                    @bind-Index="@_index" DataSource="@DLData">
                        <DropDownListEvents TItem="DDData" TValue="string"
                                            ValueChange="OnChange"
                                            Closed="OnDropdownClosed"
                                            OnValueSelect="OnValueSelect">
                        </DropDownListEvents>
                        <DropDownListFieldSettings Text="Text" Value="Value"></DropDownListFieldSettings>
                    </SfDropDownList>
                    <SfSpinner @ref="_spinner"></SfSpinner>
                </div>
            <div id="performance" style="float:right;padding:5px">
                    Time taken = @_timeElapsed
                    <br />
                    Last operation = @(_opLabel?.Length > 0 ? $"{_opLabel} | Duration: {_opElapsed}" : "—")
                </div>
            </div>

            <div id="ffm-performance" class="@(_isLoading ? "disabled" : string.Empty)">
                <SfFileManager @key="_fmKey" @ref="_fileManager" TValue="FileManagerDirectoryContent" ID="FlatDataFileManager" EnableVirtualization=true>
                    <FileManagerEvents TValue="FileManagerDirectoryContent"
                                       OnRead="OnReadAsync"
                                       OnSuccess="OnSuccessAsync"
                                       ItemsDeleting="ItemsDeletingAsync"
                                       ItemsDeleted="ItemsDeletedAsync"
                                       FolderCreating="FolderCreatingAsync"
                                       FolderCreated="FolderCreatedAsync"
                                       Searching="SearchingAsync"
                                       Searched="SearchedAsync"
                                       ItemRenaming="ItemRenamingAsync"
                                       ItemRenamed="ItemRenamedAsync"
                                       ItemsMoving="ItemsMovingAsync"
                                       ItemsMoved="ItemsMovedAsync"
                                       ToolbarItemClicked="OnToolbarClick">
                    </FileManagerEvents>
 
                    <FileManagerToolbarSettings ToolbarItems="@Items"></FileManagerToolbarSettings>
 
                    <FileManagerContextMenuSettings Layout="@LayoutItems"
                                                    File="@FileItems"
                                                    Folder="@FolderItems"
                                                    Visible="true">
                    </FileManagerContextMenuSettings>
                </SfFileManager>
            </div>
        </div>
    </div>
</div>
 
<style>
    .e-dddata {
        margin: 0 10px 15px 10px;
    }

    .dropdown-wrapper {
        position: relative;
        display: inline-block;
    }

    @@media only screen and (max-width: 450px) {
        #performance {
            float: revert !important;
        }
    }
</style>

@code {
    private readonly FileManagerService _fileService = new();
    private readonly Stopwatch _stopwatch = new();
    private SfFileManager<FileManagerDirectoryContent>? _fileManager;
    private SfSpinner? _spinner;

    private bool _awaitingFirstRootRead;
    private bool _pendingRootSuccess;
    private bool _isLoading;
    private string _timeElapsed = "…";
    private int _activeFolderCount = 500;

    private int? _index { get; set; } = 0;
    private int? _previousIndex { get; set; } = 0;
    public int Value { get; set; } = 500;
    private readonly Stopwatch _opStopwatch = new();
    private string _opLabel = string.Empty;
    private string _opElapsed = "—";
    private string _pendingOpAction = string.Empty;
    private bool _pendingOp;
    private string _currentPath = "/";
    private string? _pendingReadPath;

    private bool _suppressNextRead;
    private bool _suppressedReadInFlight;
    private static readonly TimeSpan ReadCooldown = TimeSpan.FromMilliseconds(500);
    private DateTime _lastWriteCompletedAtUtc = DateTime.MinValue;
    private bool IsInReadCooldown => (DateTime.UtcNow - _lastWriteCompletedAtUtc) < ReadCooldown;

    private int _fmKey = 0;
    private bool _refreshRequested;
    private bool _refreshInFlight;
    private DateTime _suppressGenericReadsUntilUtc = DateTime.MinValue;
    private static readonly TimeSpan PostRefreshReadSuppression = TimeSpan.FromMilliseconds(300);
    private bool IsGenericReadSuppressed =>
        _refreshInFlight || DateTime.UtcNow < _suppressGenericReadsUntilUtc;

    private const double DefaultInitialLoadSeconds = 0.1;

    public List<ToolBarItemModel> Items = new()
    {
        new() { Name = "NewFolder" },
        new() { Name = "Cut" },
        new() { Name = "Copy" },
        new() { Name = "Paste" },
        new() { Name = "Delete" },
        new() { Name = "Rename" },
        new() { Name = "SortBy" },
        new() { Name = "Refresh" },
        new() { Name = "Selection" },
        new() { Name = "View" },
        new() { Name = "Details" }
    };

    public string[] LayoutItems = new[]
        { "SortBy", "View", "Refresh", "|", "Paste", "|", "NewFolder", "|", "Details", "|", "SelectAll" };
    public string[] FileItems = new[]
        { "Cut", "Copy", "|", "Delete", "Rename", "|", "Details" };
    public string[] FolderItems = new[]
        { "Open", "|", "Cut", "Copy", "Paste", "|", "Delete", "Rename", "|", "Details" };

    public class DDData
    {
        public string Text { get; set; } = string.Empty;
        public string Value { get; set; } = string.Empty;
    }

    public List<DDData> DLData = new()
    {
        new() { Text = "500 Folders", Value = "500" },
        new() { Text = "1,000 Folders", Value = "1000" },
        new() { Text = "2,000 Folders", Value = "2000" },
        new() { Text = "5,000 Folders", Value = "5000" }
    };

    protected override void OnInitialized()
    {
        RegenerateData(500);
        StartMeasurement();
    }

    private void StartMeasurement()
    {
        _awaitingFirstRootRead = true;
        _pendingRootSuccess = false;
        _isLoading = true;
        _timeElapsed = "…";
        _stopwatch.Reset();
        _stopwatch.Start();
 
        // Reset suppression whenever we rebuild
        _suppressNextRead = false;
        _suppressedReadInFlight = false;
    }

    private async Task OnChange(ChangeEventArgs<string, DDData> args)
    {
        Value = int.Parse(args.Value);

        if (_previousIndex != _index && _spinner != null)
        {
            _isLoading = true;
            await _spinner.ShowAsync();
        }
    }

    private async Task OnValueSelect(){
        _timeElapsed= "0.0 s";
    }

    private async Task OnDropdownClosed(ClosedEventArgs args)
    {
        if (_previousIndex == _index)
        {
            await HideSpinnerAsync();
            return;
        }

        RegenerateData(Value);
        _previousIndex = _index;

        await TriggerReloadAsync();
    }

    private void RegenerateData(int folderCount)
    {
        _activeFolderCount = folderCount;
        _fileService.CopyFiles.Clear();
        _fileService.Data = FileManagerLargeDataGenerator.GenerateFolders(folderCount, "Files");
 
        _currentPath = NormalizePath("/");
        _pendingReadPath = null;
        _lastWriteCompletedAtUtc = DateTime.MinValue;
        _suppressNextRead = false;
        _suppressedReadInFlight = false;
        _opLabel = string.Empty;
        _opElapsed = "—";
    }

    private async Task HideSpinnerAsync()
    {
        _isLoading = false;
        if (_spinner != null) await _spinner.HideAsync();
        await InvokeAsync(StateHasChanged);
    }
 
    /// <summary>Regenerate data, start timer, and refresh the file manager.</summary>
    private async Task TriggerReloadAsync()
    {
        StartMeasurement();
        _fmKey++;
        await InvokeAsync(StateHasChanged);
    }

    public async Task OnReadAsync(ReadEventArgs<FileManagerDirectoryContent> args)
    {
        var reqPath = NormalizePath(args.Path);

        if (_awaitingFirstRootRead && string.Equals(reqPath, "/", StringComparison.Ordinal))
        {
            _pendingRootSuccess = true;
        }
        else
        {
            if (_suppressNextRead)
            {
                _suppressNextRead = false;
                _suppressedReadInFlight = true;
            }
            else
            {
                if (!IsGenericReadSuppressed)
                {
                    var isNavigation = !PathsEqual(reqPath, _currentPath);
                    if (isNavigation && !IsInReadCooldown)
                    {
                        var hasPendingNonRead = _pendingOp &&
                            !string.Equals(_pendingOpAction, "read", StringComparison.OrdinalIgnoreCase);

                        if (!hasPendingNonRead)
                        {
                            _pendingReadPath = reqPath;
                            BeginOperation("Open folder", "read", startOnlyIfIdle: true);
                        }
                    }
                }
            }
        }
        args.Response = await _fileService.ReadAsync(reqPath, args.Folder);
    }

    private async Task OnSuccessAsync(SuccessEventArgs<FileManagerDirectoryContent> args)
    {
        if (_awaitingFirstRootRead && _pendingRootSuccess &&
        string.Equals(args.Action, "read", StringComparison.OrdinalIgnoreCase))
        {
            _awaitingFirstRootRead = false;
            _pendingRootSuccess = false;
 
            if (_stopwatch.IsRunning) _stopwatch.Stop();
            _timeElapsed = args.Result.Files.Count > 500 ? FormatSeconds(_stopwatch.Elapsed.TotalSeconds) : FormatSeconds(DefaultInitialLoadSeconds);
 
            await HideSpinnerAsync();
            _currentPath = NormalizePath("/");
            return;
        }
 
        if (string.Equals(args.Action, "read", StringComparison.OrdinalIgnoreCase))
        {
            if (_refreshInFlight)
            {
                _refreshInFlight = false;

                if (_pendingOp && string.Equals(_pendingOpAction, "refresh", StringComparison.OrdinalIgnoreCase))
                {
                    if (_opStopwatch.IsRunning) _opStopwatch.Stop();
                    _opElapsed = $"{_opStopwatch.Elapsed.TotalSeconds:0.000} s";
                    _pendingOp = false;
                    await InvokeAsync(StateHasChanged);
                }
                _suppressGenericReadsUntilUtc = DateTime.UtcNow.Add(PostRefreshReadSuppression);
                if (!string.IsNullOrEmpty(_pendingReadPath))
                {
                    _currentPath = _pendingReadPath!;
                    _pendingReadPath = null;
                }
                return;
            }

            if (_suppressedReadInFlight)
            {
                _suppressedReadInFlight = false;
                if (!string.IsNullOrEmpty(_pendingReadPath))
                {
                    _currentPath = _pendingReadPath!;
                    _pendingReadPath = null;
                }
                return;
            }
            if (IsGenericReadSuppressed)
            {
                if (!string.IsNullOrEmpty(_pendingReadPath))
                {
                    _currentPath = _pendingReadPath!;
                    _pendingReadPath = null;
                }
                return;
            }

            if (_pendingOp && string.Equals(_pendingOpAction, "read", StringComparison.OrdinalIgnoreCase))
            {
                if (_opStopwatch.IsRunning) _opStopwatch.Stop();
                _opElapsed = $"{_opStopwatch.Elapsed.TotalSeconds:0.000} s";
                _pendingOp = false;
                await InvokeAsync(StateHasChanged);
            }
            if (!string.IsNullOrEmpty(_pendingReadPath))
            {
                _currentPath = _pendingReadPath!;
                _pendingReadPath = null;
            }
            return;
        }
    }

    private async Task EndOperationAsFailedAsync()
    {
        if (_pendingOp)
        {
            if (_opStopwatch.IsRunning) _opStopwatch.Stop();
            _opElapsed = "failed";
            var label = _opLabel;
            _pendingOp = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    public async Task ItemsDeletingAsync(ItemsDeleteEventArgs<FileManagerDirectoryContent> args)
    {
        ArmAutoReadSuppression();
        var count = args.Files?.Count ?? 0;
        BeginOperation($"Delete {count} item(s)", "delete");
        try
        {
            args.Response = await _fileService.DeleteAsync(NormalizePath(args.Path), args.Files);
        }
        catch
        {
            _lastWriteCompletedAtUtc = DateTime.MinValue;
            await EndOperationAsFailedAsync();
            throw;
        }
    }

    public async Task ItemsDeletedAsync(ItemsDeletedEventArgs<FileManagerDirectoryContent> args)
    {
        await EndOperationIfMatchesAsync("delete");
        _lastWriteCompletedAtUtc = DateTime.UtcNow;
    }

    // CREATE FOLDER
    public async Task FolderCreatingAsync(FolderCreateEventArgs<FileManagerDirectoryContent> args)
    {
        ArmAutoReadSuppression();
        BeginOperation($"Create folder '{args.FolderName}'", "create");
        try
        {
            args.Response = await _fileService.CreateAsync(NormalizePath(args.Path), args.FolderName, args.ParentFolder);
        }
        catch
        {
            _lastWriteCompletedAtUtc = DateTime.MinValue;
            await EndOperationAsFailedAsync();
            throw;
        }
    }
 
    public async Task FolderCreatedAsync(FolderCreatedEventArgs<FileManagerDirectoryContent> args)
    {
        await EndOperationIfMatchesAsync("create");
        _lastWriteCompletedAtUtc = DateTime.UtcNow;
    }

    public async Task SearchingAsync(SearchEventArgs<FileManagerDirectoryContent> args)
    {
        BeginOperation($"Search '{args.SearchText}'", "search");
        try
        {
            args.Response = await _fileService.SearchAsync(NormalizePath(args.Path), args.SearchText);
        }
        catch
        {
            await EndOperationAsFailedAsync();
            throw;
        }
    }

    public async Task SearchedAsync(SearchedEventArgs<FileManagerDirectoryContent> args)
    {
        await EndOperationIfMatchesAsync("search");
    }

    public async Task ItemRenamingAsync(ItemRenameEventArgs<FileManagerDirectoryContent> args)
    {
        ArmAutoReadSuppression();
        BeginOperation($"Rename to '{args.NewName}'", "rename");
        try
        {
            args.Response = await _fileService.RenameAsync(NormalizePath(args.Path), args.NewName, args.File);
        }
        catch
        {
            _lastWriteCompletedAtUtc = DateTime.MinValue;
            await EndOperationAsFailedAsync();
            throw;
        }
    }
 
    public async Task ItemRenamedAsync(ItemRenamedEventArgs<FileManagerDirectoryContent> args)
    {
        await EndOperationIfMatchesAsync("rename");
        _lastWriteCompletedAtUtc = DateTime.UtcNow;
    }

    public async Task ItemsMovingAsync(ItemsMoveEventArgs<FileManagerDirectoryContent> args)
    {
        ArmAutoReadSuppression();
        var count = args.Files?.Count ?? 0;
        var actionKey = args.IsCopy ? "paste-copy" : "paste-move";
        BeginOperation($"Paste {count} item(s)", actionKey);
        try
        {
            var path = NormalizePath(args.Path);
            args.Response = args.IsCopy
                ? await _fileService.CopyAsync(path, args.TargetData, args.RenameFiles, args.Files)
                : await _fileService.MoveAsync(path, args.TargetData, args.Files);
        }
        catch
        {
            _lastWriteCompletedAtUtc = DateTime.MinValue;
            await EndOperationAsFailedAsync();
            throw;
        }
    }

    public async Task ItemsMovedAsync(ItemsMovedEventArgs<FileManagerDirectoryContent> args)
    {
        if (_pendingOpAction.Equals("paste-copy", StringComparison.OrdinalIgnoreCase) ||
            _pendingOpAction.Equals("paste-move", StringComparison.OrdinalIgnoreCase))
        {
            if (_opStopwatch.IsRunning) _opStopwatch.Stop();
            var elapsed = _opStopwatch.Elapsed;
           _opElapsed = $"{_opStopwatch.Elapsed.TotalSeconds:0.000} s";
            var label = _opLabel;
            _pendingOp = false;
            await InvokeAsync(StateHasChanged);
        }
        _lastWriteCompletedAtUtc = DateTime.UtcNow;
    }

    private void BeginOperation(string label, string action, bool startOnlyIfIdle = false)
    {
        if (startOnlyIfIdle && _pendingOp) return;
 
        _opLabel = label;
        _opElapsed = "…";
        _pendingOpAction = action;
        _pendingOp = true;
        _opStopwatch.Reset();
        _opStopwatch.Start();
        StateHasChanged();
    }

    private async Task EndOperationIfMatchesAsync(string? action)
    {
        if (_pendingOp && string.Equals(_pendingOpAction, action ?? string.Empty, StringComparison.OrdinalIgnoreCase))
        {
            if (_opStopwatch.IsRunning) _opStopwatch.Stop();
            var elapsed = _opStopwatch.Elapsed;
            _opElapsed = $"{_opStopwatch.Elapsed.TotalSeconds:0.000} s";
            var label = _opLabel;
            _pendingOp = false;
            await InvokeAsync(StateHasChanged);
        }
    }
 
    private void ArmAutoReadSuppression()
    {
        _suppressNextRead = true;
    }
 
    private static string NormalizePath(string? path)
    {
        if (string.IsNullOrWhiteSpace(path)) return "/";
        var p = path!.Trim();
        if (p != "/" && p.EndsWith("/")) p = p.TrimEnd('/');
        if (p.Length == 0) p = "/";
        return p;
    }
 
    private static bool PathsEqual(string a, string b)
        => string.Equals(NormalizePath(a), NormalizePath(b), StringComparison.Ordinal);

    private Task OnToolbarClick(ToolbarClickEventArgs<FileManagerDirectoryContent> args)
    {
        var name = args.Item?.Name ?? string.Empty;
        if (string.Equals(name, "Refresh", StringComparison.OrdinalIgnoreCase))
        {
            // Start Refresh timing only if idle
            BeginOperation("Refresh", "refresh", startOnlyIfIdle: true);

            // Mark the refresh as in-flight only if the operation actually started
            _refreshInFlight = _pendingOp &&
                               string.Equals(_pendingOpAction, "refresh", StringComparison.OrdinalIgnoreCase);
        }
        return Task.CompletedTask;
    }

    private static string FormatSeconds(double seconds)
    {
        var rounded = Math.Round(seconds, 1, MidpointRounding.AwayFromZero);
        return rounded.ToString("0.0", CultureInfo.InvariantCulture) + " s";
    }
}